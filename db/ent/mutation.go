// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"main/db/ent/address"
	"main/db/ent/card"
	"main/db/ent/chat"
	"main/db/ent/message"
	"main/db/ent/order"
	"main/db/ent/orderdetail"
	"main/db/ent/orderstatus"
	"main/db/ent/predicate"
	"main/db/ent/product"
	"main/db/ent/productcategory"
	"main/db/ent/productprice"
	"main/db/ent/shoppingcart"
	"main/db/ent/typeofpackaging"
	"main/db/ent/user"
	"main/db/ent/usercategory"
	"main/db/ent/usertoken"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAddress         = "Address"
	TypeCard            = "Card"
	TypeChat            = "Chat"
	TypeMessage         = "Message"
	TypeOrder           = "Order"
	TypeOrderDetail     = "OrderDetail"
	TypeOrderStatus     = "OrderStatus"
	TypeProduct         = "Product"
	TypeProductCategory = "ProductCategory"
	TypeProductPrice    = "ProductPrice"
	TypeShoppingCart    = "ShoppingCart"
	TypeTypeOfPackaging = "TypeOfPackaging"
	TypeUser            = "User"
	TypeUserCategory    = "UserCategory"
	TypeUserToken       = "UserToken"
)

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op             Op
	typ            string
	id             *int
	city           *string
	street_name    *string
	house_number   *string
	store_name     *string
	clearedFields  map[string]struct{}
	user           map[int]struct{}
	removeduser    map[int]struct{}
	cleareduser    bool
	address        map[int]struct{}
	removedaddress map[int]struct{}
	clearedaddress bool
	done           bool
	oldValue       func(context.Context) (*Address, error)
	predicates     []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id int) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *AddressMutation) ClearCity() {
	m.city = nil
	m.clearedFields[address.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *AddressMutation) CityCleared() bool {
	_, ok := m.clearedFields[address.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, address.FieldCity)
}

// SetStreetName sets the "street_name" field.
func (m *AddressMutation) SetStreetName(s string) {
	m.street_name = &s
}

// StreetName returns the value of the "street_name" field in the mutation.
func (m *AddressMutation) StreetName() (r string, exists bool) {
	v := m.street_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetName returns the old "street_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStreetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetName: %w", err)
	}
	return oldValue.StreetName, nil
}

// ClearStreetName clears the value of the "street_name" field.
func (m *AddressMutation) ClearStreetName() {
	m.street_name = nil
	m.clearedFields[address.FieldStreetName] = struct{}{}
}

// StreetNameCleared returns if the "street_name" field was cleared in this mutation.
func (m *AddressMutation) StreetNameCleared() bool {
	_, ok := m.clearedFields[address.FieldStreetName]
	return ok
}

// ResetStreetName resets all changes to the "street_name" field.
func (m *AddressMutation) ResetStreetName() {
	m.street_name = nil
	delete(m.clearedFields, address.FieldStreetName)
}

// SetHouseNumber sets the "house_number" field.
func (m *AddressMutation) SetHouseNumber(s string) {
	m.house_number = &s
}

// HouseNumber returns the value of the "house_number" field in the mutation.
func (m *AddressMutation) HouseNumber() (r string, exists bool) {
	v := m.house_number
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseNumber returns the old "house_number" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldHouseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseNumber: %w", err)
	}
	return oldValue.HouseNumber, nil
}

// ClearHouseNumber clears the value of the "house_number" field.
func (m *AddressMutation) ClearHouseNumber() {
	m.house_number = nil
	m.clearedFields[address.FieldHouseNumber] = struct{}{}
}

// HouseNumberCleared returns if the "house_number" field was cleared in this mutation.
func (m *AddressMutation) HouseNumberCleared() bool {
	_, ok := m.clearedFields[address.FieldHouseNumber]
	return ok
}

// ResetHouseNumber resets all changes to the "house_number" field.
func (m *AddressMutation) ResetHouseNumber() {
	m.house_number = nil
	delete(m.clearedFields, address.FieldHouseNumber)
}

// SetStoreName sets the "store_name" field.
func (m *AddressMutation) SetStoreName(s string) {
	m.store_name = &s
}

// StoreName returns the value of the "store_name" field in the mutation.
func (m *AddressMutation) StoreName() (r string, exists bool) {
	v := m.store_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreName returns the old "store_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldStoreName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreName: %w", err)
	}
	return oldValue.StoreName, nil
}

// ClearStoreName clears the value of the "store_name" field.
func (m *AddressMutation) ClearStoreName() {
	m.store_name = nil
	m.clearedFields[address.FieldStoreName] = struct{}{}
}

// StoreNameCleared returns if the "store_name" field was cleared in this mutation.
func (m *AddressMutation) StoreNameCleared() bool {
	_, ok := m.clearedFields[address.FieldStoreName]
	return ok
}

// ResetStoreName resets all changes to the "store_name" field.
func (m *AddressMutation) ResetStoreName() {
	m.store_name = nil
	delete(m.clearedFields, address.FieldStoreName)
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *AddressMutation) AddUserIDs(ids ...int) {
	if m.user == nil {
		m.user = make(map[int]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *AddressMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AddressMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *AddressMutation) RemoveUserIDs(ids ...int) {
	if m.removeduser == nil {
		m.removeduser = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *AddressMutation) RemovedUserIDs() (ids []int) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *AddressMutation) UserIDs() (ids []int) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AddressMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddAddresIDs adds the "address" edge to the Order entity by ids.
func (m *AddressMutation) AddAddresIDs(ids ...int) {
	if m.address == nil {
		m.address = make(map[int]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the Order entity.
func (m *AddressMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Order entity was cleared.
func (m *AddressMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the Order entity by IDs.
func (m *AddressMutation) RemoveAddresIDs(ids ...int) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.address, ids[i])
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the Order entity.
func (m *AddressMutation) RemovedAddressIDs() (ids []int) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *AddressMutation) AddressIDs() (ids []int) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *AddressMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.street_name != nil {
		fields = append(fields, address.FieldStreetName)
	}
	if m.house_number != nil {
		fields = append(fields, address.FieldHouseNumber)
	}
	if m.store_name != nil {
		fields = append(fields, address.FieldStoreName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldCity:
		return m.City()
	case address.FieldStreetName:
		return m.StreetName()
	case address.FieldHouseNumber:
		return m.HouseNumber()
	case address.FieldStoreName:
		return m.StoreName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldStreetName:
		return m.OldStreetName(ctx)
	case address.FieldHouseNumber:
		return m.OldHouseNumber(ctx)
	case address.FieldStoreName:
		return m.OldStoreName(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldStreetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetName(v)
		return nil
	case address.FieldHouseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseNumber(v)
		return nil
	case address.FieldStoreName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreName(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldCity) {
		fields = append(fields, address.FieldCity)
	}
	if m.FieldCleared(address.FieldStreetName) {
		fields = append(fields, address.FieldStreetName)
	}
	if m.FieldCleared(address.FieldHouseNumber) {
		fields = append(fields, address.FieldHouseNumber)
	}
	if m.FieldCleared(address.FieldStoreName) {
		fields = append(fields, address.FieldStoreName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldCity:
		m.ClearCity()
		return nil
	case address.FieldStreetName:
		m.ClearStreetName()
		return nil
	case address.FieldHouseNumber:
		m.ClearHouseNumber()
		return nil
	case address.FieldStoreName:
		m.ClearStoreName()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldStreetName:
		m.ResetStreetName()
		return nil
	case address.FieldHouseNumber:
		m.ResetHouseNumber()
		return nil
	case address.FieldStoreName:
		m.ResetStoreName()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, address.EdgeUser)
	}
	if m.address != nil {
		edges = append(edges, address.EdgeAddress)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser != nil {
		edges = append(edges, address.EdgeUser)
	}
	if m.removedaddress != nil {
		edges = append(edges, address.EdgeAddress)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, address.EdgeUser)
	}
	if m.clearedaddress {
		edges = append(edges, address.EdgeAddress)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeUser:
		return m.cleareduser
	case address.EdgeAddress:
		return m.clearedaddress
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeUser:
		m.ResetUser()
		return nil
	case address.EdgeAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// CardMutation represents an operation that mutates the Card nodes in the graph.
type CardMutation struct {
	config
	op              Op
	typ             string
	id              *int
	number          *string
	expiration_date *time.Time
	name            *string
	token           *string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Card, error)
	predicates      []predicate.Card
}

var _ ent.Mutation = (*CardMutation)(nil)

// cardOption allows management of the mutation configuration using functional options.
type cardOption func(*CardMutation)

// newCardMutation creates new mutation for the Card entity.
func newCardMutation(c config, op Op, opts ...cardOption) *CardMutation {
	m := &CardMutation{
		config:        c,
		op:            op,
		typ:           TypeCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCardID sets the ID field of the mutation.
func withCardID(id int) cardOption {
	return func(m *CardMutation) {
		var (
			err   error
			once  sync.Once
			value *Card
		)
		m.oldValue = func(ctx context.Context) (*Card, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Card.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCard sets the old Card of the mutation.
func withCard(node *Card) cardOption {
	return func(m *CardMutation) {
		m.oldValue = func(context.Context) (*Card, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CardMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CardMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Card.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetNumber sets the "number" field.
func (m *CardMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *CardMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ClearNumber clears the value of the "number" field.
func (m *CardMutation) ClearNumber() {
	m.number = nil
	m.clearedFields[card.FieldNumber] = struct{}{}
}

// NumberCleared returns if the "number" field was cleared in this mutation.
func (m *CardMutation) NumberCleared() bool {
	_, ok := m.clearedFields[card.FieldNumber]
	return ok
}

// ResetNumber resets all changes to the "number" field.
func (m *CardMutation) ResetNumber() {
	m.number = nil
	delete(m.clearedFields, card.FieldNumber)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *CardMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *CardMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *CardMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[card.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *CardMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[card.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *CardMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, card.FieldExpirationDate)
}

// SetName sets the "name" field.
func (m *CardMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CardMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *CardMutation) ClearName() {
	m.name = nil
	m.clearedFields[card.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *CardMutation) NameCleared() bool {
	_, ok := m.clearedFields[card.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *CardMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, card.FieldName)
}

// SetToken sets the "token" field.
func (m *CardMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *CardMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *CardMutation) ClearToken() {
	m.token = nil
	m.clearedFields[card.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *CardMutation) TokenCleared() bool {
	_, ok := m.clearedFields[card.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *CardMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, card.FieldToken)
}

// SetUserID sets the "user_id" field.
func (m *CardMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CardMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Card entity.
// If the Card object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CardMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *CardMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[card.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *CardMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[card.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CardMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, card.FieldUserID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *CardMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[card.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CardMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CardMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CardMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CardMutation builder.
func (m *CardMutation) Where(ps ...predicate.Card) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Card, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Card).
func (m *CardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CardMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.number != nil {
		fields = append(fields, card.FieldNumber)
	}
	if m.expiration_date != nil {
		fields = append(fields, card.FieldExpirationDate)
	}
	if m.name != nil {
		fields = append(fields, card.FieldName)
	}
	if m.token != nil {
		fields = append(fields, card.FieldToken)
	}
	if m.user != nil {
		fields = append(fields, card.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case card.FieldNumber:
		return m.Number()
	case card.FieldExpirationDate:
		return m.ExpirationDate()
	case card.FieldName:
		return m.Name()
	case card.FieldToken:
		return m.Token()
	case card.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case card.FieldNumber:
		return m.OldNumber(ctx)
	case card.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case card.FieldName:
		return m.OldName(ctx)
	case card.FieldToken:
		return m.OldToken(ctx)
	case card.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Card field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case card.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case card.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case card.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case card.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case card.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CardMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Card numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(card.FieldNumber) {
		fields = append(fields, card.FieldNumber)
	}
	if m.FieldCleared(card.FieldExpirationDate) {
		fields = append(fields, card.FieldExpirationDate)
	}
	if m.FieldCleared(card.FieldName) {
		fields = append(fields, card.FieldName)
	}
	if m.FieldCleared(card.FieldToken) {
		fields = append(fields, card.FieldToken)
	}
	if m.FieldCleared(card.FieldUserID) {
		fields = append(fields, card.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CardMutation) ClearField(name string) error {
	switch name {
	case card.FieldNumber:
		m.ClearNumber()
		return nil
	case card.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	case card.FieldName:
		m.ClearName()
		return nil
	case card.FieldToken:
		m.ClearToken()
		return nil
	case card.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Card nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CardMutation) ResetField(name string) error {
	switch name {
	case card.FieldNumber:
		m.ResetNumber()
		return nil
	case card.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case card.FieldName:
		m.ResetName()
		return nil
	case card.FieldToken:
		m.ResetToken()
		return nil
	case card.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Card field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CardMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, card.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case card.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, card.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CardMutation) EdgeCleared(name string) bool {
	switch name {
	case card.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CardMutation) ClearEdge(name string) error {
	switch name {
	case card.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Card unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CardMutation) ResetEdge(name string) error {
	switch name {
	case card.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Card edge %s", name)
}

// ChatMutation represents an operation that mutates the Chat nodes in the graph.
type ChatMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	token               *string
	created_at          *string
	manager_id          *int
	addmanager_id       *int
	clearedFields       map[string]struct{}
	user                *int
	cleareduser         bool
	chat_message        map[int]struct{}
	removedchat_message map[int]struct{}
	clearedchat_message bool
	done                bool
	oldValue            func(context.Context) (*Chat, error)
	predicates          []predicate.Chat
}

var _ ent.Mutation = (*ChatMutation)(nil)

// chatOption allows management of the mutation configuration using functional options.
type chatOption func(*ChatMutation)

// newChatMutation creates new mutation for the Chat entity.
func newChatMutation(c config, op Op, opts ...chatOption) *ChatMutation {
	m := &ChatMutation{
		config:        c,
		op:            op,
		typ:           TypeChat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChatID sets the ID field of the mutation.
func withChatID(id int) chatOption {
	return func(m *ChatMutation) {
		var (
			err   error
			once  sync.Once
			value *Chat
		)
		m.oldValue = func(ctx context.Context) (*Chat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChat sets the old Chat of the mutation.
func withChat(node *Chat) chatOption {
	return func(m *ChatMutation) {
		m.oldValue = func(context.Context) (*Chat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChatMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChatMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *ChatMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *ChatMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *ChatMutation) ClearToken() {
	m.token = nil
	m.clearedFields[chat.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *ChatMutation) TokenCleared() bool {
	_, ok := m.clearedFields[chat.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *ChatMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, chat.FieldToken)
}

// SetCreatedAt sets the "created_at" field.
func (m *ChatMutation) SetCreatedAt(s string) {
	m.created_at = &s
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChatMutation) CreatedAt() (r string, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldCreatedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ChatMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[chat.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ChatMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[chat.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChatMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, chat.FieldCreatedAt)
}

// SetUserID sets the "user_id" field.
func (m *ChatMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ChatMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ChatMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[chat.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ChatMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[chat.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ChatMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, chat.FieldUserID)
}

// SetManagerID sets the "manager_id" field.
func (m *ChatMutation) SetManagerID(i int) {
	m.manager_id = &i
	m.addmanager_id = nil
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *ChatMutation) ManagerID() (r int, exists bool) {
	v := m.manager_id
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Chat entity.
// If the Chat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChatMutation) OldManagerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// AddManagerID adds i to the "manager_id" field.
func (m *ChatMutation) AddManagerID(i int) {
	if m.addmanager_id != nil {
		*m.addmanager_id += i
	} else {
		m.addmanager_id = &i
	}
}

// AddedManagerID returns the value that was added to the "manager_id" field in this mutation.
func (m *ChatMutation) AddedManagerID() (r int, exists bool) {
	v := m.addmanager_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *ChatMutation) ClearManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	m.clearedFields[chat.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *ChatMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[chat.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *ChatMutation) ResetManagerID() {
	m.manager_id = nil
	m.addmanager_id = nil
	delete(m.clearedFields, chat.FieldManagerID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChatMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[chat.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChatMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChatMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChatMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddChatMessageIDs adds the "chat_message" edge to the Message entity by ids.
func (m *ChatMutation) AddChatMessageIDs(ids ...int) {
	if m.chat_message == nil {
		m.chat_message = make(map[int]struct{})
	}
	for i := range ids {
		m.chat_message[ids[i]] = struct{}{}
	}
}

// ClearChatMessage clears the "chat_message" edge to the Message entity.
func (m *ChatMutation) ClearChatMessage() {
	m.clearedchat_message = true
}

// ChatMessageCleared reports if the "chat_message" edge to the Message entity was cleared.
func (m *ChatMutation) ChatMessageCleared() bool {
	return m.clearedchat_message
}

// RemoveChatMessageIDs removes the "chat_message" edge to the Message entity by IDs.
func (m *ChatMutation) RemoveChatMessageIDs(ids ...int) {
	if m.removedchat_message == nil {
		m.removedchat_message = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chat_message, ids[i])
		m.removedchat_message[ids[i]] = struct{}{}
	}
}

// RemovedChatMessage returns the removed IDs of the "chat_message" edge to the Message entity.
func (m *ChatMutation) RemovedChatMessageIDs() (ids []int) {
	for id := range m.removedchat_message {
		ids = append(ids, id)
	}
	return
}

// ChatMessageIDs returns the "chat_message" edge IDs in the mutation.
func (m *ChatMutation) ChatMessageIDs() (ids []int) {
	for id := range m.chat_message {
		ids = append(ids, id)
	}
	return
}

// ResetChatMessage resets all changes to the "chat_message" edge.
func (m *ChatMutation) ResetChatMessage() {
	m.chat_message = nil
	m.clearedchat_message = false
	m.removedchat_message = nil
}

// Where appends a list predicates to the ChatMutation builder.
func (m *ChatMutation) Where(ps ...predicate.Chat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chat).
func (m *ChatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChatMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.token != nil {
		fields = append(fields, chat.FieldToken)
	}
	if m.created_at != nil {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.user != nil {
		fields = append(fields, chat.FieldUserID)
	}
	if m.manager_id != nil {
		fields = append(fields, chat.FieldManagerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldToken:
		return m.Token()
	case chat.FieldCreatedAt:
		return m.CreatedAt()
	case chat.FieldUserID:
		return m.UserID()
	case chat.FieldManagerID:
		return m.ManagerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chat.FieldToken:
		return m.OldToken(ctx)
	case chat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case chat.FieldUserID:
		return m.OldUserID(ctx)
	case chat.FieldManagerID:
		return m.OldManagerID(ctx)
	}
	return nil, fmt.Errorf("unknown Chat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chat.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case chat.FieldCreatedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case chat.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case chat.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChatMutation) AddedFields() []string {
	var fields []string
	if m.addmanager_id != nil {
		fields = append(fields, chat.FieldManagerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChatMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chat.FieldManagerID:
		return m.AddedManagerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChatMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chat.FieldManagerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddManagerID(v)
		return nil
	}
	return fmt.Errorf("unknown Chat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chat.FieldToken) {
		fields = append(fields, chat.FieldToken)
	}
	if m.FieldCleared(chat.FieldCreatedAt) {
		fields = append(fields, chat.FieldCreatedAt)
	}
	if m.FieldCleared(chat.FieldUserID) {
		fields = append(fields, chat.FieldUserID)
	}
	if m.FieldCleared(chat.FieldManagerID) {
		fields = append(fields, chat.FieldManagerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChatMutation) ClearField(name string) error {
	switch name {
	case chat.FieldToken:
		m.ClearToken()
		return nil
	case chat.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case chat.FieldUserID:
		m.ClearUserID()
		return nil
	case chat.FieldManagerID:
		m.ClearManagerID()
		return nil
	}
	return fmt.Errorf("unknown Chat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChatMutation) ResetField(name string) error {
	switch name {
	case chat.FieldToken:
		m.ResetToken()
		return nil
	case chat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case chat.FieldUserID:
		m.ResetUserID()
		return nil
	case chat.FieldManagerID:
		m.ResetManagerID()
		return nil
	}
	return fmt.Errorf("unknown Chat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChatMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, chat.EdgeUser)
	}
	if m.chat_message != nil {
		edges = append(edges, chat.EdgeChatMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case chat.EdgeChatMessage:
		ids := make([]ent.Value, 0, len(m.chat_message))
		for id := range m.chat_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchat_message != nil {
		edges = append(edges, chat.EdgeChatMessage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChatMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chat.EdgeChatMessage:
		ids := make([]ent.Value, 0, len(m.removedchat_message))
		for id := range m.removedchat_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, chat.EdgeUser)
	}
	if m.clearedchat_message {
		edges = append(edges, chat.EdgeChatMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChatMutation) EdgeCleared(name string) bool {
	switch name {
	case chat.EdgeUser:
		return m.cleareduser
	case chat.EdgeChatMessage:
		return m.clearedchat_message
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChatMutation) ClearEdge(name string) error {
	switch name {
	case chat.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Chat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChatMutation) ResetEdge(name string) error {
	switch name {
	case chat.EdgeUser:
		m.ResetUser()
		return nil
	case chat.EdgeChatMessage:
		m.ResetChatMessage()
		return nil
	}
	return fmt.Errorf("unknown Chat edge %s", name)
}

// MessageMutation represents an operation that mutates the Message nodes in the graph.
type MessageMutation struct {
	config
	op            Op
	typ           string
	id            *int
	text          *string
	sended_at     *string
	file_path     *string
	file_type     *string
	clearedFields map[string]struct{}
	chat          *int
	clearedchat   bool
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Message, error)
	predicates    []predicate.Message
}

var _ ent.Mutation = (*MessageMutation)(nil)

// messageOption allows management of the mutation configuration using functional options.
type messageOption func(*MessageMutation)

// newMessageMutation creates new mutation for the Message entity.
func newMessageMutation(c config, op Op, opts ...messageOption) *MessageMutation {
	m := &MessageMutation{
		config:        c,
		op:            op,
		typ:           TypeMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMessageID sets the ID field of the mutation.
func withMessageID(id int) messageOption {
	return func(m *MessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Message
		)
		m.oldValue = func(ctx context.Context) (*Message, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Message.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMessage sets the old Message of the mutation.
func withMessage(node *Message) messageOption {
	return func(m *MessageMutation) {
		m.oldValue = func(context.Context) (*Message, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MessageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MessageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Message.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetText sets the "text" field.
func (m *MessageMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *MessageMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ClearText clears the value of the "text" field.
func (m *MessageMutation) ClearText() {
	m.text = nil
	m.clearedFields[message.FieldText] = struct{}{}
}

// TextCleared returns if the "text" field was cleared in this mutation.
func (m *MessageMutation) TextCleared() bool {
	_, ok := m.clearedFields[message.FieldText]
	return ok
}

// ResetText resets all changes to the "text" field.
func (m *MessageMutation) ResetText() {
	m.text = nil
	delete(m.clearedFields, message.FieldText)
}

// SetSendedAt sets the "sended_at" field.
func (m *MessageMutation) SetSendedAt(s string) {
	m.sended_at = &s
}

// SendedAt returns the value of the "sended_at" field in the mutation.
func (m *MessageMutation) SendedAt() (r string, exists bool) {
	v := m.sended_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSendedAt returns the old "sended_at" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldSendedAt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSendedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSendedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSendedAt: %w", err)
	}
	return oldValue.SendedAt, nil
}

// ClearSendedAt clears the value of the "sended_at" field.
func (m *MessageMutation) ClearSendedAt() {
	m.sended_at = nil
	m.clearedFields[message.FieldSendedAt] = struct{}{}
}

// SendedAtCleared returns if the "sended_at" field was cleared in this mutation.
func (m *MessageMutation) SendedAtCleared() bool {
	_, ok := m.clearedFields[message.FieldSendedAt]
	return ok
}

// ResetSendedAt resets all changes to the "sended_at" field.
func (m *MessageMutation) ResetSendedAt() {
	m.sended_at = nil
	delete(m.clearedFields, message.FieldSendedAt)
}

// SetFilePath sets the "file_path" field.
func (m *MessageMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *MessageMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ClearFilePath clears the value of the "file_path" field.
func (m *MessageMutation) ClearFilePath() {
	m.file_path = nil
	m.clearedFields[message.FieldFilePath] = struct{}{}
}

// FilePathCleared returns if the "file_path" field was cleared in this mutation.
func (m *MessageMutation) FilePathCleared() bool {
	_, ok := m.clearedFields[message.FieldFilePath]
	return ok
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *MessageMutation) ResetFilePath() {
	m.file_path = nil
	delete(m.clearedFields, message.FieldFilePath)
}

// SetFileType sets the "file_type" field.
func (m *MessageMutation) SetFileType(s string) {
	m.file_type = &s
}

// FileType returns the value of the "file_type" field in the mutation.
func (m *MessageMutation) FileType() (r string, exists bool) {
	v := m.file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFileType returns the old "file_type" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileType: %w", err)
	}
	return oldValue.FileType, nil
}

// ClearFileType clears the value of the "file_type" field.
func (m *MessageMutation) ClearFileType() {
	m.file_type = nil
	m.clearedFields[message.FieldFileType] = struct{}{}
}

// FileTypeCleared returns if the "file_type" field was cleared in this mutation.
func (m *MessageMutation) FileTypeCleared() bool {
	_, ok := m.clearedFields[message.FieldFileType]
	return ok
}

// ResetFileType resets all changes to the "file_type" field.
func (m *MessageMutation) ResetFileType() {
	m.file_type = nil
	delete(m.clearedFields, message.FieldFileType)
}

// SetChatID sets the "chat_id" field.
func (m *MessageMutation) SetChatID(i int) {
	m.chat = &i
}

// ChatID returns the value of the "chat_id" field in the mutation.
func (m *MessageMutation) ChatID() (r int, exists bool) {
	v := m.chat
	if v == nil {
		return
	}
	return *v, true
}

// OldChatID returns the old "chat_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldChatID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChatID: %w", err)
	}
	return oldValue.ChatID, nil
}

// ClearChatID clears the value of the "chat_id" field.
func (m *MessageMutation) ClearChatID() {
	m.chat = nil
	m.clearedFields[message.FieldChatID] = struct{}{}
}

// ChatIDCleared returns if the "chat_id" field was cleared in this mutation.
func (m *MessageMutation) ChatIDCleared() bool {
	_, ok := m.clearedFields[message.FieldChatID]
	return ok
}

// ResetChatID resets all changes to the "chat_id" field.
func (m *MessageMutation) ResetChatID() {
	m.chat = nil
	delete(m.clearedFields, message.FieldChatID)
}

// SetUserID sets the "user_id" field.
func (m *MessageMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *MessageMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Message entity.
// If the Message object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MessageMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *MessageMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[message.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *MessageMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[message.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *MessageMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, message.FieldUserID)
}

// ClearChat clears the "chat" edge to the Chat entity.
func (m *MessageMutation) ClearChat() {
	m.clearedchat = true
	m.clearedFields[message.FieldChatID] = struct{}{}
}

// ChatCleared reports if the "chat" edge to the Chat entity was cleared.
func (m *MessageMutation) ChatCleared() bool {
	return m.ChatIDCleared() || m.clearedchat
}

// ChatIDs returns the "chat" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChatID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) ChatIDs() (ids []int) {
	if id := m.chat; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChat resets all changes to the "chat" edge.
func (m *MessageMutation) ResetChat() {
	m.chat = nil
	m.clearedchat = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *MessageMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[message.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MessageMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MessageMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MessageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MessageMutation builder.
func (m *MessageMutation) Where(ps ...predicate.Message) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Message, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Message).
func (m *MessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MessageMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.text != nil {
		fields = append(fields, message.FieldText)
	}
	if m.sended_at != nil {
		fields = append(fields, message.FieldSendedAt)
	}
	if m.file_path != nil {
		fields = append(fields, message.FieldFilePath)
	}
	if m.file_type != nil {
		fields = append(fields, message.FieldFileType)
	}
	if m.chat != nil {
		fields = append(fields, message.FieldChatID)
	}
	if m.user != nil {
		fields = append(fields, message.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case message.FieldText:
		return m.Text()
	case message.FieldSendedAt:
		return m.SendedAt()
	case message.FieldFilePath:
		return m.FilePath()
	case message.FieldFileType:
		return m.FileType()
	case message.FieldChatID:
		return m.ChatID()
	case message.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case message.FieldText:
		return m.OldText(ctx)
	case message.FieldSendedAt:
		return m.OldSendedAt(ctx)
	case message.FieldFilePath:
		return m.OldFilePath(ctx)
	case message.FieldFileType:
		return m.OldFileType(ctx)
	case message.FieldChatID:
		return m.OldChatID(ctx)
	case message.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Message field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case message.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case message.FieldSendedAt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendedAt(v)
		return nil
	case message.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case message.FieldFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileType(v)
		return nil
	case message.FieldChatID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChatID(v)
		return nil
	case message.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MessageMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Message numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(message.FieldText) {
		fields = append(fields, message.FieldText)
	}
	if m.FieldCleared(message.FieldSendedAt) {
		fields = append(fields, message.FieldSendedAt)
	}
	if m.FieldCleared(message.FieldFilePath) {
		fields = append(fields, message.FieldFilePath)
	}
	if m.FieldCleared(message.FieldFileType) {
		fields = append(fields, message.FieldFileType)
	}
	if m.FieldCleared(message.FieldChatID) {
		fields = append(fields, message.FieldChatID)
	}
	if m.FieldCleared(message.FieldUserID) {
		fields = append(fields, message.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MessageMutation) ClearField(name string) error {
	switch name {
	case message.FieldText:
		m.ClearText()
		return nil
	case message.FieldSendedAt:
		m.ClearSendedAt()
		return nil
	case message.FieldFilePath:
		m.ClearFilePath()
		return nil
	case message.FieldFileType:
		m.ClearFileType()
		return nil
	case message.FieldChatID:
		m.ClearChatID()
		return nil
	case message.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Message nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MessageMutation) ResetField(name string) error {
	switch name {
	case message.FieldText:
		m.ResetText()
		return nil
	case message.FieldSendedAt:
		m.ResetSendedAt()
		return nil
	case message.FieldFilePath:
		m.ResetFilePath()
		return nil
	case message.FieldFileType:
		m.ResetFileType()
		return nil
	case message.FieldChatID:
		m.ResetChatID()
		return nil
	case message.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Message field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.chat != nil {
		edges = append(edges, message.EdgeChat)
	}
	if m.user != nil {
		edges = append(edges, message.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case message.EdgeChat:
		if id := m.chat; id != nil {
			return []ent.Value{*id}
		}
	case message.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchat {
		edges = append(edges, message.EdgeChat)
	}
	if m.cleareduser {
		edges = append(edges, message.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MessageMutation) EdgeCleared(name string) bool {
	switch name {
	case message.EdgeChat:
		return m.clearedchat
	case message.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MessageMutation) ClearEdge(name string) error {
	switch name {
	case message.EdgeChat:
		m.ClearChat()
		return nil
	case message.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Message unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MessageMutation) ResetEdge(name string) error {
	switch name {
	case message.EdgeChat:
		m.ResetChat()
		return nil
	case message.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Message edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	order_date            *time.Time
	desired_delivery_date *time.Time
	total_amount          *float64
	addtotal_amount       *float64
	clearedFields         map[string]struct{}
	order_status          *int
	clearedorder_status   bool
	user                  *int
	cleareduser           bool
	addres_order          *int
	clearedaddres_order   bool
	_order                map[int]struct{}
	removed_order         map[int]struct{}
	cleared_order         bool
	done                  bool
	oldValue              func(context.Context) (*Order, error)
	predicates            []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderDate sets the "order_date" field.
func (m *OrderMutation) SetOrderDate(t time.Time) {
	m.order_date = &t
}

// OrderDate returns the value of the "order_date" field in the mutation.
func (m *OrderMutation) OrderDate() (r time.Time, exists bool) {
	v := m.order_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderDate returns the old "order_date" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderDate: %w", err)
	}
	return oldValue.OrderDate, nil
}

// ClearOrderDate clears the value of the "order_date" field.
func (m *OrderMutation) ClearOrderDate() {
	m.order_date = nil
	m.clearedFields[order.FieldOrderDate] = struct{}{}
}

// OrderDateCleared returns if the "order_date" field was cleared in this mutation.
func (m *OrderMutation) OrderDateCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderDate]
	return ok
}

// ResetOrderDate resets all changes to the "order_date" field.
func (m *OrderMutation) ResetOrderDate() {
	m.order_date = nil
	delete(m.clearedFields, order.FieldOrderDate)
}

// SetDesiredDeliveryDate sets the "desired_delivery_date" field.
func (m *OrderMutation) SetDesiredDeliveryDate(t time.Time) {
	m.desired_delivery_date = &t
}

// DesiredDeliveryDate returns the value of the "desired_delivery_date" field in the mutation.
func (m *OrderMutation) DesiredDeliveryDate() (r time.Time, exists bool) {
	v := m.desired_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDesiredDeliveryDate returns the old "desired_delivery_date" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDesiredDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesiredDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesiredDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesiredDeliveryDate: %w", err)
	}
	return oldValue.DesiredDeliveryDate, nil
}

// ClearDesiredDeliveryDate clears the value of the "desired_delivery_date" field.
func (m *OrderMutation) ClearDesiredDeliveryDate() {
	m.desired_delivery_date = nil
	m.clearedFields[order.FieldDesiredDeliveryDate] = struct{}{}
}

// DesiredDeliveryDateCleared returns if the "desired_delivery_date" field was cleared in this mutation.
func (m *OrderMutation) DesiredDeliveryDateCleared() bool {
	_, ok := m.clearedFields[order.FieldDesiredDeliveryDate]
	return ok
}

// ResetDesiredDeliveryDate resets all changes to the "desired_delivery_date" field.
func (m *OrderMutation) ResetDesiredDeliveryDate() {
	m.desired_delivery_date = nil
	delete(m.clearedFields, order.FieldDesiredDeliveryDate)
}

// SetTotalAmount sets the "total_amount" field.
func (m *OrderMutation) SetTotalAmount(f float64) {
	m.total_amount = &f
	m.addtotal_amount = nil
}

// TotalAmount returns the value of the "total_amount" field in the mutation.
func (m *OrderMutation) TotalAmount() (r float64, exists bool) {
	v := m.total_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAmount returns the old "total_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotalAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAmount: %w", err)
	}
	return oldValue.TotalAmount, nil
}

// AddTotalAmount adds f to the "total_amount" field.
func (m *OrderMutation) AddTotalAmount(f float64) {
	if m.addtotal_amount != nil {
		*m.addtotal_amount += f
	} else {
		m.addtotal_amount = &f
	}
}

// AddedTotalAmount returns the value that was added to the "total_amount" field in this mutation.
func (m *OrderMutation) AddedTotalAmount() (r float64, exists bool) {
	v := m.addtotal_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalAmount clears the value of the "total_amount" field.
func (m *OrderMutation) ClearTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	m.clearedFields[order.FieldTotalAmount] = struct{}{}
}

// TotalAmountCleared returns if the "total_amount" field was cleared in this mutation.
func (m *OrderMutation) TotalAmountCleared() bool {
	_, ok := m.clearedFields[order.FieldTotalAmount]
	return ok
}

// ResetTotalAmount resets all changes to the "total_amount" field.
func (m *OrderMutation) ResetTotalAmount() {
	m.total_amount = nil
	m.addtotal_amount = nil
	delete(m.clearedFields, order.FieldTotalAmount)
}

// SetOrderStatusID sets the "order_status_id" field.
func (m *OrderMutation) SetOrderStatusID(i int) {
	m.order_status = &i
}

// OrderStatusID returns the value of the "order_status_id" field in the mutation.
func (m *OrderMutation) OrderStatusID() (r int, exists bool) {
	v := m.order_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderStatusID returns the old "order_status_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderStatusID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderStatusID: %w", err)
	}
	return oldValue.OrderStatusID, nil
}

// ClearOrderStatusID clears the value of the "order_status_id" field.
func (m *OrderMutation) ClearOrderStatusID() {
	m.order_status = nil
	m.clearedFields[order.FieldOrderStatusID] = struct{}{}
}

// OrderStatusIDCleared returns if the "order_status_id" field was cleared in this mutation.
func (m *OrderMutation) OrderStatusIDCleared() bool {
	_, ok := m.clearedFields[order.FieldOrderStatusID]
	return ok
}

// ResetOrderStatusID resets all changes to the "order_status_id" field.
func (m *OrderMutation) ResetOrderStatusID() {
	m.order_status = nil
	delete(m.clearedFields, order.FieldOrderStatusID)
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *OrderMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *OrderMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[order.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, order.FieldUserID)
}

// SetAddressID sets the "address_id" field.
func (m *OrderMutation) SetAddressID(i int) {
	m.addres_order = &i
}

// AddressID returns the value of the "address_id" field in the mutation.
func (m *OrderMutation) AddressID() (r int, exists bool) {
	v := m.addres_order
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressID returns the old "address_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAddressID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressID: %w", err)
	}
	return oldValue.AddressID, nil
}

// ClearAddressID clears the value of the "address_id" field.
func (m *OrderMutation) ClearAddressID() {
	m.addres_order = nil
	m.clearedFields[order.FieldAddressID] = struct{}{}
}

// AddressIDCleared returns if the "address_id" field was cleared in this mutation.
func (m *OrderMutation) AddressIDCleared() bool {
	_, ok := m.clearedFields[order.FieldAddressID]
	return ok
}

// ResetAddressID resets all changes to the "address_id" field.
func (m *OrderMutation) ResetAddressID() {
	m.addres_order = nil
	delete(m.clearedFields, order.FieldAddressID)
}

// ClearOrderStatus clears the "order_status" edge to the OrderStatus entity.
func (m *OrderMutation) ClearOrderStatus() {
	m.clearedorder_status = true
	m.clearedFields[order.FieldOrderStatusID] = struct{}{}
}

// OrderStatusCleared reports if the "order_status" edge to the OrderStatus entity was cleared.
func (m *OrderMutation) OrderStatusCleared() bool {
	return m.OrderStatusIDCleared() || m.clearedorder_status
}

// OrderStatusIDs returns the "order_status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderStatusID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) OrderStatusIDs() (ids []int) {
	if id := m.order_status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderStatus resets all changes to the "order_status" edge.
func (m *OrderMutation) ResetOrderStatus() {
	m.order_status = nil
	m.clearedorder_status = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAddresOrderID sets the "addres_order" edge to the Address entity by id.
func (m *OrderMutation) SetAddresOrderID(id int) {
	m.addres_order = &id
}

// ClearAddresOrder clears the "addres_order" edge to the Address entity.
func (m *OrderMutation) ClearAddresOrder() {
	m.clearedaddres_order = true
	m.clearedFields[order.FieldAddressID] = struct{}{}
}

// AddresOrderCleared reports if the "addres_order" edge to the Address entity was cleared.
func (m *OrderMutation) AddresOrderCleared() bool {
	return m.AddressIDCleared() || m.clearedaddres_order
}

// AddresOrderID returns the "addres_order" edge ID in the mutation.
func (m *OrderMutation) AddresOrderID() (id int, exists bool) {
	if m.addres_order != nil {
		return *m.addres_order, true
	}
	return
}

// AddresOrderIDs returns the "addres_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddresOrderID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AddresOrderIDs() (ids []int) {
	if id := m.addres_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddresOrder resets all changes to the "addres_order" edge.
func (m *OrderMutation) ResetAddresOrder() {
	m.addres_order = nil
	m.clearedaddres_order = false
}

// AddOrderIDs adds the "order" edge to the OrderDetail entity by ids.
func (m *OrderMutation) AddOrderIDs(ids ...int) {
	if m._order == nil {
		m._order = make(map[int]struct{})
	}
	for i := range ids {
		m._order[ids[i]] = struct{}{}
	}
}

// ClearOrder clears the "order" edge to the OrderDetail entity.
func (m *OrderMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the OrderDetail entity was cleared.
func (m *OrderMutation) OrderCleared() bool {
	return m.cleared_order
}

// RemoveOrderIDs removes the "order" edge to the OrderDetail entity by IDs.
func (m *OrderMutation) RemoveOrderIDs(ids ...int) {
	if m.removed_order == nil {
		m.removed_order = make(map[int]struct{})
	}
	for i := range ids {
		delete(m._order, ids[i])
		m.removed_order[ids[i]] = struct{}{}
	}
}

// RemovedOrder returns the removed IDs of the "order" edge to the OrderDetail entity.
func (m *OrderMutation) RemovedOrderIDs() (ids []int) {
	for id := range m.removed_order {
		ids = append(ids, id)
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
func (m *OrderMutation) OrderIDs() (ids []int) {
	for id := range m._order {
		ids = append(ids, id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
	m.removed_order = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.order_date != nil {
		fields = append(fields, order.FieldOrderDate)
	}
	if m.desired_delivery_date != nil {
		fields = append(fields, order.FieldDesiredDeliveryDate)
	}
	if m.total_amount != nil {
		fields = append(fields, order.FieldTotalAmount)
	}
	if m.order_status != nil {
		fields = append(fields, order.FieldOrderStatusID)
	}
	if m.user != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.addres_order != nil {
		fields = append(fields, order.FieldAddressID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldOrderDate:
		return m.OrderDate()
	case order.FieldDesiredDeliveryDate:
		return m.DesiredDeliveryDate()
	case order.FieldTotalAmount:
		return m.TotalAmount()
	case order.FieldOrderStatusID:
		return m.OrderStatusID()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldAddressID:
		return m.AddressID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldOrderDate:
		return m.OldOrderDate(ctx)
	case order.FieldDesiredDeliveryDate:
		return m.OldDesiredDeliveryDate(ctx)
	case order.FieldTotalAmount:
		return m.OldTotalAmount(ctx)
	case order.FieldOrderStatusID:
		return m.OldOrderStatusID(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldAddressID:
		return m.OldAddressID(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldOrderDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderDate(v)
		return nil
	case order.FieldDesiredDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesiredDeliveryDate(v)
		return nil
	case order.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAmount(v)
		return nil
	case order.FieldOrderStatusID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderStatusID(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldAddressID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressID(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_amount != nil {
		fields = append(fields, order.FieldTotalAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTotalAmount:
		return m.AddedTotalAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldTotalAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldOrderDate) {
		fields = append(fields, order.FieldOrderDate)
	}
	if m.FieldCleared(order.FieldDesiredDeliveryDate) {
		fields = append(fields, order.FieldDesiredDeliveryDate)
	}
	if m.FieldCleared(order.FieldTotalAmount) {
		fields = append(fields, order.FieldTotalAmount)
	}
	if m.FieldCleared(order.FieldOrderStatusID) {
		fields = append(fields, order.FieldOrderStatusID)
	}
	if m.FieldCleared(order.FieldUserID) {
		fields = append(fields, order.FieldUserID)
	}
	if m.FieldCleared(order.FieldAddressID) {
		fields = append(fields, order.FieldAddressID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldOrderDate:
		m.ClearOrderDate()
		return nil
	case order.FieldDesiredDeliveryDate:
		m.ClearDesiredDeliveryDate()
		return nil
	case order.FieldTotalAmount:
		m.ClearTotalAmount()
		return nil
	case order.FieldOrderStatusID:
		m.ClearOrderStatusID()
		return nil
	case order.FieldUserID:
		m.ClearUserID()
		return nil
	case order.FieldAddressID:
		m.ClearAddressID()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldOrderDate:
		m.ResetOrderDate()
		return nil
	case order.FieldDesiredDeliveryDate:
		m.ResetDesiredDeliveryDate()
		return nil
	case order.FieldTotalAmount:
		m.ResetTotalAmount()
		return nil
	case order.FieldOrderStatusID:
		m.ResetOrderStatusID()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldAddressID:
		m.ResetAddressID()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.order_status != nil {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.addres_order != nil {
		edges = append(edges, order.EdgeAddresOrder)
	}
	if m._order != nil {
		edges = append(edges, order.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderStatus:
		if id := m.order_status; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAddresOrder:
		if id := m.addres_order; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrder:
		ids := make([]ent.Value, 0, len(m._order))
		for id := range m._order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removed_order != nil {
		edges = append(edges, order.EdgeOrder)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrder:
		ids := make([]ent.Value, 0, len(m.removed_order))
		for id := range m.removed_order {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedorder_status {
		edges = append(edges, order.EdgeOrderStatus)
	}
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedaddres_order {
		edges = append(edges, order.EdgeAddresOrder)
	}
	if m.cleared_order {
		edges = append(edges, order.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeOrderStatus:
		return m.clearedorder_status
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgeAddresOrder:
		return m.clearedaddres_order
	case order.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeOrderStatus:
		m.ClearOrderStatus()
		return nil
	case order.EdgeUser:
		m.ClearUser()
		return nil
	case order.EdgeAddresOrder:
		m.ClearAddresOrder()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeOrderStatus:
		m.ResetOrderStatus()
		return nil
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgeAddresOrder:
		m.ResetAddresOrder()
		return nil
	case order.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderDetailMutation represents an operation that mutates the OrderDetail nodes in the graph.
type OrderDetailMutation struct {
	config
	op              Op
	typ             string
	id              *int
	quantity        *int
	addquantity     *int
	product_id      *int
	addproduct_id   *int
	clearedFields   map[string]struct{}
	_order          *int
	cleared_order   bool
	products        *int
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*OrderDetail, error)
	predicates      []predicate.OrderDetail
}

var _ ent.Mutation = (*OrderDetailMutation)(nil)

// orderdetailOption allows management of the mutation configuration using functional options.
type orderdetailOption func(*OrderDetailMutation)

// newOrderDetailMutation creates new mutation for the OrderDetail entity.
func newOrderDetailMutation(c config, op Op, opts ...orderdetailOption) *OrderDetailMutation {
	m := &OrderDetailMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderDetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderDetailID sets the ID field of the mutation.
func withOrderDetailID(id int) orderdetailOption {
	return func(m *OrderDetailMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderDetail
		)
		m.oldValue = func(ctx context.Context) (*OrderDetail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderDetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderDetail sets the old OrderDetail of the mutation.
func withOrderDetail(node *OrderDetail) orderdetailOption {
	return func(m *OrderDetailMutation) {
		m.oldValue = func(context.Context) (*OrderDetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderDetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderDetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderDetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderDetailMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderDetail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *OrderDetailMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *OrderDetailMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *OrderDetailMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *OrderDetailMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *OrderDetailMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[orderdetail.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *OrderDetailMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[orderdetail.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *OrderDetailMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, orderdetail.FieldQuantity)
}

// SetOrderID sets the "order_id" field.
func (m *OrderDetailMutation) SetOrderID(i int) {
	m.products = &i
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderDetailMutation) OrderID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldOrderID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *OrderDetailMutation) ClearOrderID() {
	m.products = nil
	m.clearedFields[orderdetail.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *OrderDetailMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[orderdetail.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderDetailMutation) ResetOrderID() {
	m.products = nil
	delete(m.clearedFields, orderdetail.FieldOrderID)
}

// SetProductID sets the "product_id" field.
func (m *OrderDetailMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderDetailMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderDetail entity.
// If the OrderDetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderDetailMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderDetailMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderDetailMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *OrderDetailMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[orderdetail.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *OrderDetailMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[orderdetail.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderDetailMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, orderdetail.FieldProductID)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderDetailMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderdetail.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderDetailMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderDetailMutation) OrderIDs() (ids []int) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderDetailMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *OrderDetailMutation) SetProductsID(id int) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *OrderDetailMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[orderdetail.FieldOrderID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *OrderDetailMutation) ProductsCleared() bool {
	return m.OrderIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *OrderDetailMutation) ProductsID() (id int, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *OrderDetailMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *OrderDetailMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// Where appends a list predicates to the OrderDetailMutation builder.
func (m *OrderDetailMutation) Where(ps ...predicate.OrderDetail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderDetailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderDetailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderDetail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderDetailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderDetailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderDetail).
func (m *OrderDetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderDetailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.quantity != nil {
		fields = append(fields, orderdetail.FieldQuantity)
	}
	if m.products != nil {
		fields = append(fields, orderdetail.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderdetail.FieldProductID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderDetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldQuantity:
		return m.Quantity()
	case orderdetail.FieldOrderID:
		return m.OrderID()
	case orderdetail.FieldProductID:
		return m.ProductID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderDetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderdetail.FieldQuantity:
		return m.OldQuantity(ctx)
	case orderdetail.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderdetail.FieldProductID:
		return m.OldProductID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderDetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case orderdetail.FieldOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderdetail.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderDetailMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, orderdetail.FieldQuantity)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderdetail.FieldProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderDetailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderdetail.FieldQuantity:
		return m.AddedQuantity()
	case orderdetail.FieldProductID:
		return m.AddedProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderDetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderdetail.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	case orderdetail.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderDetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderDetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderdetail.FieldQuantity) {
		fields = append(fields, orderdetail.FieldQuantity)
	}
	if m.FieldCleared(orderdetail.FieldOrderID) {
		fields = append(fields, orderdetail.FieldOrderID)
	}
	if m.FieldCleared(orderdetail.FieldProductID) {
		fields = append(fields, orderdetail.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderDetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderDetailMutation) ClearField(name string) error {
	switch name {
	case orderdetail.FieldQuantity:
		m.ClearQuantity()
		return nil
	case orderdetail.FieldOrderID:
		m.ClearOrderID()
		return nil
	case orderdetail.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderDetailMutation) ResetField(name string) error {
	switch name {
	case orderdetail.FieldQuantity:
		m.ResetQuantity()
		return nil
	case orderdetail.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderdetail.FieldProductID:
		m.ResetProductID()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderDetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, orderdetail.EdgeOrder)
	}
	if m.products != nil {
		edges = append(edges, orderdetail.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderDetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderdetail.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case orderdetail.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderDetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderDetailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderDetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, orderdetail.EdgeOrder)
	}
	if m.clearedproducts {
		edges = append(edges, orderdetail.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderDetailMutation) EdgeCleared(name string) bool {
	switch name {
	case orderdetail.EdgeOrder:
		return m.cleared_order
	case orderdetail.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderDetailMutation) ClearEdge(name string) error {
	switch name {
	case orderdetail.EdgeOrder:
		m.ClearOrder()
		return nil
	case orderdetail.EdgeProducts:
		m.ClearProducts()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderDetailMutation) ResetEdge(name string) error {
	switch name {
	case orderdetail.EdgeOrder:
		m.ResetOrder()
		return nil
	case orderdetail.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown OrderDetail edge %s", name)
}

// OrderStatusMutation represents an operation that mutates the OrderStatus nodes in the graph.
type OrderStatusMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	status        map[int]struct{}
	removedstatus map[int]struct{}
	clearedstatus bool
	done          bool
	oldValue      func(context.Context) (*OrderStatus, error)
	predicates    []predicate.OrderStatus
}

var _ ent.Mutation = (*OrderStatusMutation)(nil)

// orderstatusOption allows management of the mutation configuration using functional options.
type orderstatusOption func(*OrderStatusMutation)

// newOrderStatusMutation creates new mutation for the OrderStatus entity.
func newOrderStatusMutation(c config, op Op, opts ...orderstatusOption) *OrderStatusMutation {
	m := &OrderStatusMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderStatusID sets the ID field of the mutation.
func withOrderStatusID(id int) orderstatusOption {
	return func(m *OrderStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderStatus
		)
		m.oldValue = func(ctx context.Context) (*OrderStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderStatus sets the old OrderStatus of the mutation.
func withOrderStatus(node *OrderStatus) orderstatusOption {
	return func(m *OrderStatusMutation) {
		m.oldValue = func(context.Context) (*OrderStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderStatusMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderStatusMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *OrderStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrderStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OrderStatus entity.
// If the OrderStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *OrderStatusMutation) ClearName() {
	m.name = nil
	m.clearedFields[orderstatus.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *OrderStatusMutation) NameCleared() bool {
	_, ok := m.clearedFields[orderstatus.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *OrderStatusMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, orderstatus.FieldName)
}

// AddStatuIDs adds the "status" edge to the Order entity by ids.
func (m *OrderStatusMutation) AddStatuIDs(ids ...int) {
	if m.status == nil {
		m.status = make(map[int]struct{})
	}
	for i := range ids {
		m.status[ids[i]] = struct{}{}
	}
}

// ClearStatus clears the "status" edge to the Order entity.
func (m *OrderStatusMutation) ClearStatus() {
	m.clearedstatus = true
}

// StatusCleared reports if the "status" edge to the Order entity was cleared.
func (m *OrderStatusMutation) StatusCleared() bool {
	return m.clearedstatus
}

// RemoveStatuIDs removes the "status" edge to the Order entity by IDs.
func (m *OrderStatusMutation) RemoveStatuIDs(ids ...int) {
	if m.removedstatus == nil {
		m.removedstatus = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.status, ids[i])
		m.removedstatus[ids[i]] = struct{}{}
	}
}

// RemovedStatus returns the removed IDs of the "status" edge to the Order entity.
func (m *OrderStatusMutation) RemovedStatusIDs() (ids []int) {
	for id := range m.removedstatus {
		ids = append(ids, id)
	}
	return
}

// StatusIDs returns the "status" edge IDs in the mutation.
func (m *OrderStatusMutation) StatusIDs() (ids []int) {
	for id := range m.status {
		ids = append(ids, id)
	}
	return
}

// ResetStatus resets all changes to the "status" edge.
func (m *OrderStatusMutation) ResetStatus() {
	m.status = nil
	m.clearedstatus = false
	m.removedstatus = nil
}

// Where appends a list predicates to the OrderStatusMutation builder.
func (m *OrderStatusMutation) Where(ps ...predicate.OrderStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderStatus).
func (m *OrderStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderStatusMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, orderstatus.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderstatus.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderstatus.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown OrderStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderstatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown OrderStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderstatus.FieldName) {
		fields = append(fields, orderstatus.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderStatusMutation) ClearField(name string) error {
	switch name {
	case orderstatus.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderStatusMutation) ResetField(name string) error {
	switch name {
	case orderstatus.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.status != nil {
		edges = append(edges, orderstatus.EdgeStatus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderstatus.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.status))
		for id := range m.status {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatus != nil {
		edges = append(edges, orderstatus.EdgeStatus)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderstatus.EdgeStatus:
		ids := make([]ent.Value, 0, len(m.removedstatus))
		for id := range m.removedstatus {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstatus {
		edges = append(edges, orderstatus.EdgeStatus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case orderstatus.EdgeStatus:
		return m.clearedstatus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderStatusMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderStatusMutation) ResetEdge(name string) error {
	switch name {
	case orderstatus.EdgeStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OrderStatus edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	name                             *string
	weight                           *float64
	addweight                        *float64
	product_composition              *string
	min_storage_temp                 *int
	addmin_storage_temp              *int
	max_storage_temp                 *int
	addmax_storage_temp              *int
	shelf_life                       *string
	picture                          *string
	clearedFields                    map[string]struct{}
	order_detail_product             map[int]struct{}
	removedorder_detail_product      map[int]struct{}
	clearedorder_detail_product      bool
	shopping_cart_product            map[int]struct{}
	removedshopping_cart_product     map[int]struct{}
	clearedshopping_cart_product     bool
	product_price_product            map[int]struct{}
	removedproduct_price_product     map[int]struct{}
	clearedproduct_price_product     bool
	product_category                 *int
	clearedproduct_category          bool
	type_of_packaging_product        *int
	clearedtype_of_packaging_product bool
	done                             bool
	oldValue                         func(context.Context) (*Product, error)
	predicates                       []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id int) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductMutation) ClearName() {
	m.name = nil
	m.clearedFields[product.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductMutation) NameCleared() bool {
	_, ok := m.clearedFields[product.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, product.FieldName)
}

// SetWeight sets the "weight" field.
func (m *ProductMutation) SetWeight(f float64) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *ProductMutation) Weight() (r float64, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to the "weight" field.
func (m *ProductMutation) AddWeight(f float64) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *ProductMutation) AddedWeight() (r float64, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeight clears the value of the "weight" field.
func (m *ProductMutation) ClearWeight() {
	m.weight = nil
	m.addweight = nil
	m.clearedFields[product.FieldWeight] = struct{}{}
}

// WeightCleared returns if the "weight" field was cleared in this mutation.
func (m *ProductMutation) WeightCleared() bool {
	_, ok := m.clearedFields[product.FieldWeight]
	return ok
}

// ResetWeight resets all changes to the "weight" field.
func (m *ProductMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
	delete(m.clearedFields, product.FieldWeight)
}

// SetProductComposition sets the "product_composition" field.
func (m *ProductMutation) SetProductComposition(s string) {
	m.product_composition = &s
}

// ProductComposition returns the value of the "product_composition" field in the mutation.
func (m *ProductMutation) ProductComposition() (r string, exists bool) {
	v := m.product_composition
	if v == nil {
		return
	}
	return *v, true
}

// OldProductComposition returns the old "product_composition" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductComposition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductComposition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductComposition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductComposition: %w", err)
	}
	return oldValue.ProductComposition, nil
}

// ClearProductComposition clears the value of the "product_composition" field.
func (m *ProductMutation) ClearProductComposition() {
	m.product_composition = nil
	m.clearedFields[product.FieldProductComposition] = struct{}{}
}

// ProductCompositionCleared returns if the "product_composition" field was cleared in this mutation.
func (m *ProductMutation) ProductCompositionCleared() bool {
	_, ok := m.clearedFields[product.FieldProductComposition]
	return ok
}

// ResetProductComposition resets all changes to the "product_composition" field.
func (m *ProductMutation) ResetProductComposition() {
	m.product_composition = nil
	delete(m.clearedFields, product.FieldProductComposition)
}

// SetMinStorageTemp sets the "min_storage_temp" field.
func (m *ProductMutation) SetMinStorageTemp(i int) {
	m.min_storage_temp = &i
	m.addmin_storage_temp = nil
}

// MinStorageTemp returns the value of the "min_storage_temp" field in the mutation.
func (m *ProductMutation) MinStorageTemp() (r int, exists bool) {
	v := m.min_storage_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMinStorageTemp returns the old "min_storage_temp" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMinStorageTemp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinStorageTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinStorageTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinStorageTemp: %w", err)
	}
	return oldValue.MinStorageTemp, nil
}

// AddMinStorageTemp adds i to the "min_storage_temp" field.
func (m *ProductMutation) AddMinStorageTemp(i int) {
	if m.addmin_storage_temp != nil {
		*m.addmin_storage_temp += i
	} else {
		m.addmin_storage_temp = &i
	}
}

// AddedMinStorageTemp returns the value that was added to the "min_storage_temp" field in this mutation.
func (m *ProductMutation) AddedMinStorageTemp() (r int, exists bool) {
	v := m.addmin_storage_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinStorageTemp clears the value of the "min_storage_temp" field.
func (m *ProductMutation) ClearMinStorageTemp() {
	m.min_storage_temp = nil
	m.addmin_storage_temp = nil
	m.clearedFields[product.FieldMinStorageTemp] = struct{}{}
}

// MinStorageTempCleared returns if the "min_storage_temp" field was cleared in this mutation.
func (m *ProductMutation) MinStorageTempCleared() bool {
	_, ok := m.clearedFields[product.FieldMinStorageTemp]
	return ok
}

// ResetMinStorageTemp resets all changes to the "min_storage_temp" field.
func (m *ProductMutation) ResetMinStorageTemp() {
	m.min_storage_temp = nil
	m.addmin_storage_temp = nil
	delete(m.clearedFields, product.FieldMinStorageTemp)
}

// SetMaxStorageTemp sets the "max_storage_temp" field.
func (m *ProductMutation) SetMaxStorageTemp(i int) {
	m.max_storage_temp = &i
	m.addmax_storage_temp = nil
}

// MaxStorageTemp returns the value of the "max_storage_temp" field in the mutation.
func (m *ProductMutation) MaxStorageTemp() (r int, exists bool) {
	v := m.max_storage_temp
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxStorageTemp returns the old "max_storage_temp" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldMaxStorageTemp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxStorageTemp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxStorageTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxStorageTemp: %w", err)
	}
	return oldValue.MaxStorageTemp, nil
}

// AddMaxStorageTemp adds i to the "max_storage_temp" field.
func (m *ProductMutation) AddMaxStorageTemp(i int) {
	if m.addmax_storage_temp != nil {
		*m.addmax_storage_temp += i
	} else {
		m.addmax_storage_temp = &i
	}
}

// AddedMaxStorageTemp returns the value that was added to the "max_storage_temp" field in this mutation.
func (m *ProductMutation) AddedMaxStorageTemp() (r int, exists bool) {
	v := m.addmax_storage_temp
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxStorageTemp clears the value of the "max_storage_temp" field.
func (m *ProductMutation) ClearMaxStorageTemp() {
	m.max_storage_temp = nil
	m.addmax_storage_temp = nil
	m.clearedFields[product.FieldMaxStorageTemp] = struct{}{}
}

// MaxStorageTempCleared returns if the "max_storage_temp" field was cleared in this mutation.
func (m *ProductMutation) MaxStorageTempCleared() bool {
	_, ok := m.clearedFields[product.FieldMaxStorageTemp]
	return ok
}

// ResetMaxStorageTemp resets all changes to the "max_storage_temp" field.
func (m *ProductMutation) ResetMaxStorageTemp() {
	m.max_storage_temp = nil
	m.addmax_storage_temp = nil
	delete(m.clearedFields, product.FieldMaxStorageTemp)
}

// SetShelfLife sets the "shelf_life" field.
func (m *ProductMutation) SetShelfLife(s string) {
	m.shelf_life = &s
}

// ShelfLife returns the value of the "shelf_life" field in the mutation.
func (m *ProductMutation) ShelfLife() (r string, exists bool) {
	v := m.shelf_life
	if v == nil {
		return
	}
	return *v, true
}

// OldShelfLife returns the old "shelf_life" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldShelfLife(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShelfLife is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShelfLife requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShelfLife: %w", err)
	}
	return oldValue.ShelfLife, nil
}

// ClearShelfLife clears the value of the "shelf_life" field.
func (m *ProductMutation) ClearShelfLife() {
	m.shelf_life = nil
	m.clearedFields[product.FieldShelfLife] = struct{}{}
}

// ShelfLifeCleared returns if the "shelf_life" field was cleared in this mutation.
func (m *ProductMutation) ShelfLifeCleared() bool {
	_, ok := m.clearedFields[product.FieldShelfLife]
	return ok
}

// ResetShelfLife resets all changes to the "shelf_life" field.
func (m *ProductMutation) ResetShelfLife() {
	m.shelf_life = nil
	delete(m.clearedFields, product.FieldShelfLife)
}

// SetPicture sets the "picture" field.
func (m *ProductMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *ProductMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldPicture(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *ProductMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[product.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *ProductMutation) PictureCleared() bool {
	_, ok := m.clearedFields[product.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *ProductMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, product.FieldPicture)
}

// SetProductCategoryID sets the "product_category_id" field.
func (m *ProductMutation) SetProductCategoryID(i int) {
	m.product_category = &i
}

// ProductCategoryID returns the value of the "product_category_id" field in the mutation.
func (m *ProductMutation) ProductCategoryID() (r int, exists bool) {
	v := m.product_category
	if v == nil {
		return
	}
	return *v, true
}

// OldProductCategoryID returns the old "product_category_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldProductCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductCategoryID: %w", err)
	}
	return oldValue.ProductCategoryID, nil
}

// ClearProductCategoryID clears the value of the "product_category_id" field.
func (m *ProductMutation) ClearProductCategoryID() {
	m.product_category = nil
	m.clearedFields[product.FieldProductCategoryID] = struct{}{}
}

// ProductCategoryIDCleared returns if the "product_category_id" field was cleared in this mutation.
func (m *ProductMutation) ProductCategoryIDCleared() bool {
	_, ok := m.clearedFields[product.FieldProductCategoryID]
	return ok
}

// ResetProductCategoryID resets all changes to the "product_category_id" field.
func (m *ProductMutation) ResetProductCategoryID() {
	m.product_category = nil
	delete(m.clearedFields, product.FieldProductCategoryID)
}

// SetTypeOfPackagingID sets the "type_of_packaging_id" field.
func (m *ProductMutation) SetTypeOfPackagingID(i int) {
	m.type_of_packaging_product = &i
}

// TypeOfPackagingID returns the value of the "type_of_packaging_id" field in the mutation.
func (m *ProductMutation) TypeOfPackagingID() (r int, exists bool) {
	v := m.type_of_packaging_product
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeOfPackagingID returns the old "type_of_packaging_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTypeOfPackagingID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeOfPackagingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeOfPackagingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeOfPackagingID: %w", err)
	}
	return oldValue.TypeOfPackagingID, nil
}

// ClearTypeOfPackagingID clears the value of the "type_of_packaging_id" field.
func (m *ProductMutation) ClearTypeOfPackagingID() {
	m.type_of_packaging_product = nil
	m.clearedFields[product.FieldTypeOfPackagingID] = struct{}{}
}

// TypeOfPackagingIDCleared returns if the "type_of_packaging_id" field was cleared in this mutation.
func (m *ProductMutation) TypeOfPackagingIDCleared() bool {
	_, ok := m.clearedFields[product.FieldTypeOfPackagingID]
	return ok
}

// ResetTypeOfPackagingID resets all changes to the "type_of_packaging_id" field.
func (m *ProductMutation) ResetTypeOfPackagingID() {
	m.type_of_packaging_product = nil
	delete(m.clearedFields, product.FieldTypeOfPackagingID)
}

// AddOrderDetailProductIDs adds the "order_detail_product" edge to the OrderDetail entity by ids.
func (m *ProductMutation) AddOrderDetailProductIDs(ids ...int) {
	if m.order_detail_product == nil {
		m.order_detail_product = make(map[int]struct{})
	}
	for i := range ids {
		m.order_detail_product[ids[i]] = struct{}{}
	}
}

// ClearOrderDetailProduct clears the "order_detail_product" edge to the OrderDetail entity.
func (m *ProductMutation) ClearOrderDetailProduct() {
	m.clearedorder_detail_product = true
}

// OrderDetailProductCleared reports if the "order_detail_product" edge to the OrderDetail entity was cleared.
func (m *ProductMutation) OrderDetailProductCleared() bool {
	return m.clearedorder_detail_product
}

// RemoveOrderDetailProductIDs removes the "order_detail_product" edge to the OrderDetail entity by IDs.
func (m *ProductMutation) RemoveOrderDetailProductIDs(ids ...int) {
	if m.removedorder_detail_product == nil {
		m.removedorder_detail_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_detail_product, ids[i])
		m.removedorder_detail_product[ids[i]] = struct{}{}
	}
}

// RemovedOrderDetailProduct returns the removed IDs of the "order_detail_product" edge to the OrderDetail entity.
func (m *ProductMutation) RemovedOrderDetailProductIDs() (ids []int) {
	for id := range m.removedorder_detail_product {
		ids = append(ids, id)
	}
	return
}

// OrderDetailProductIDs returns the "order_detail_product" edge IDs in the mutation.
func (m *ProductMutation) OrderDetailProductIDs() (ids []int) {
	for id := range m.order_detail_product {
		ids = append(ids, id)
	}
	return
}

// ResetOrderDetailProduct resets all changes to the "order_detail_product" edge.
func (m *ProductMutation) ResetOrderDetailProduct() {
	m.order_detail_product = nil
	m.clearedorder_detail_product = false
	m.removedorder_detail_product = nil
}

// AddShoppingCartProductIDs adds the "shopping_cart_product" edge to the ShoppingCart entity by ids.
func (m *ProductMutation) AddShoppingCartProductIDs(ids ...int) {
	if m.shopping_cart_product == nil {
		m.shopping_cart_product = make(map[int]struct{})
	}
	for i := range ids {
		m.shopping_cart_product[ids[i]] = struct{}{}
	}
}

// ClearShoppingCartProduct clears the "shopping_cart_product" edge to the ShoppingCart entity.
func (m *ProductMutation) ClearShoppingCartProduct() {
	m.clearedshopping_cart_product = true
}

// ShoppingCartProductCleared reports if the "shopping_cart_product" edge to the ShoppingCart entity was cleared.
func (m *ProductMutation) ShoppingCartProductCleared() bool {
	return m.clearedshopping_cart_product
}

// RemoveShoppingCartProductIDs removes the "shopping_cart_product" edge to the ShoppingCart entity by IDs.
func (m *ProductMutation) RemoveShoppingCartProductIDs(ids ...int) {
	if m.removedshopping_cart_product == nil {
		m.removedshopping_cart_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shopping_cart_product, ids[i])
		m.removedshopping_cart_product[ids[i]] = struct{}{}
	}
}

// RemovedShoppingCartProduct returns the removed IDs of the "shopping_cart_product" edge to the ShoppingCart entity.
func (m *ProductMutation) RemovedShoppingCartProductIDs() (ids []int) {
	for id := range m.removedshopping_cart_product {
		ids = append(ids, id)
	}
	return
}

// ShoppingCartProductIDs returns the "shopping_cart_product" edge IDs in the mutation.
func (m *ProductMutation) ShoppingCartProductIDs() (ids []int) {
	for id := range m.shopping_cart_product {
		ids = append(ids, id)
	}
	return
}

// ResetShoppingCartProduct resets all changes to the "shopping_cart_product" edge.
func (m *ProductMutation) ResetShoppingCartProduct() {
	m.shopping_cart_product = nil
	m.clearedshopping_cart_product = false
	m.removedshopping_cart_product = nil
}

// AddProductPriceProductIDs adds the "product_price_product" edge to the ProductPrice entity by ids.
func (m *ProductMutation) AddProductPriceProductIDs(ids ...int) {
	if m.product_price_product == nil {
		m.product_price_product = make(map[int]struct{})
	}
	for i := range ids {
		m.product_price_product[ids[i]] = struct{}{}
	}
}

// ClearProductPriceProduct clears the "product_price_product" edge to the ProductPrice entity.
func (m *ProductMutation) ClearProductPriceProduct() {
	m.clearedproduct_price_product = true
}

// ProductPriceProductCleared reports if the "product_price_product" edge to the ProductPrice entity was cleared.
func (m *ProductMutation) ProductPriceProductCleared() bool {
	return m.clearedproduct_price_product
}

// RemoveProductPriceProductIDs removes the "product_price_product" edge to the ProductPrice entity by IDs.
func (m *ProductMutation) RemoveProductPriceProductIDs(ids ...int) {
	if m.removedproduct_price_product == nil {
		m.removedproduct_price_product = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.product_price_product, ids[i])
		m.removedproduct_price_product[ids[i]] = struct{}{}
	}
}

// RemovedProductPriceProduct returns the removed IDs of the "product_price_product" edge to the ProductPrice entity.
func (m *ProductMutation) RemovedProductPriceProductIDs() (ids []int) {
	for id := range m.removedproduct_price_product {
		ids = append(ids, id)
	}
	return
}

// ProductPriceProductIDs returns the "product_price_product" edge IDs in the mutation.
func (m *ProductMutation) ProductPriceProductIDs() (ids []int) {
	for id := range m.product_price_product {
		ids = append(ids, id)
	}
	return
}

// ResetProductPriceProduct resets all changes to the "product_price_product" edge.
func (m *ProductMutation) ResetProductPriceProduct() {
	m.product_price_product = nil
	m.clearedproduct_price_product = false
	m.removedproduct_price_product = nil
}

// ClearProductCategory clears the "product_category" edge to the ProductCategory entity.
func (m *ProductMutation) ClearProductCategory() {
	m.clearedproduct_category = true
	m.clearedFields[product.FieldProductCategoryID] = struct{}{}
}

// ProductCategoryCleared reports if the "product_category" edge to the ProductCategory entity was cleared.
func (m *ProductMutation) ProductCategoryCleared() bool {
	return m.ProductCategoryIDCleared() || m.clearedproduct_category
}

// ProductCategoryIDs returns the "product_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductCategoryID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) ProductCategoryIDs() (ids []int) {
	if id := m.product_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductCategory resets all changes to the "product_category" edge.
func (m *ProductMutation) ResetProductCategory() {
	m.product_category = nil
	m.clearedproduct_category = false
}

// SetTypeOfPackagingProductID sets the "type_of_packaging_product" edge to the TypeOfPackaging entity by id.
func (m *ProductMutation) SetTypeOfPackagingProductID(id int) {
	m.type_of_packaging_product = &id
}

// ClearTypeOfPackagingProduct clears the "type_of_packaging_product" edge to the TypeOfPackaging entity.
func (m *ProductMutation) ClearTypeOfPackagingProduct() {
	m.clearedtype_of_packaging_product = true
	m.clearedFields[product.FieldTypeOfPackagingID] = struct{}{}
}

// TypeOfPackagingProductCleared reports if the "type_of_packaging_product" edge to the TypeOfPackaging entity was cleared.
func (m *ProductMutation) TypeOfPackagingProductCleared() bool {
	return m.TypeOfPackagingIDCleared() || m.clearedtype_of_packaging_product
}

// TypeOfPackagingProductID returns the "type_of_packaging_product" edge ID in the mutation.
func (m *ProductMutation) TypeOfPackagingProductID() (id int, exists bool) {
	if m.type_of_packaging_product != nil {
		return *m.type_of_packaging_product, true
	}
	return
}

// TypeOfPackagingProductIDs returns the "type_of_packaging_product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TypeOfPackagingProductID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) TypeOfPackagingProductIDs() (ids []int) {
	if id := m.type_of_packaging_product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTypeOfPackagingProduct resets all changes to the "type_of_packaging_product" edge.
func (m *ProductMutation) ResetTypeOfPackagingProduct() {
	m.type_of_packaging_product = nil
	m.clearedtype_of_packaging_product = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.weight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.product_composition != nil {
		fields = append(fields, product.FieldProductComposition)
	}
	if m.min_storage_temp != nil {
		fields = append(fields, product.FieldMinStorageTemp)
	}
	if m.max_storage_temp != nil {
		fields = append(fields, product.FieldMaxStorageTemp)
	}
	if m.shelf_life != nil {
		fields = append(fields, product.FieldShelfLife)
	}
	if m.picture != nil {
		fields = append(fields, product.FieldPicture)
	}
	if m.product_category != nil {
		fields = append(fields, product.FieldProductCategoryID)
	}
	if m.type_of_packaging_product != nil {
		fields = append(fields, product.FieldTypeOfPackagingID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldName:
		return m.Name()
	case product.FieldWeight:
		return m.Weight()
	case product.FieldProductComposition:
		return m.ProductComposition()
	case product.FieldMinStorageTemp:
		return m.MinStorageTemp()
	case product.FieldMaxStorageTemp:
		return m.MaxStorageTemp()
	case product.FieldShelfLife:
		return m.ShelfLife()
	case product.FieldPicture:
		return m.Picture()
	case product.FieldProductCategoryID:
		return m.ProductCategoryID()
	case product.FieldTypeOfPackagingID:
		return m.TypeOfPackagingID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldWeight:
		return m.OldWeight(ctx)
	case product.FieldProductComposition:
		return m.OldProductComposition(ctx)
	case product.FieldMinStorageTemp:
		return m.OldMinStorageTemp(ctx)
	case product.FieldMaxStorageTemp:
		return m.OldMaxStorageTemp(ctx)
	case product.FieldShelfLife:
		return m.OldShelfLife(ctx)
	case product.FieldPicture:
		return m.OldPicture(ctx)
	case product.FieldProductCategoryID:
		return m.OldProductCategoryID(ctx)
	case product.FieldTypeOfPackagingID:
		return m.OldTypeOfPackagingID(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case product.FieldProductComposition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductComposition(v)
		return nil
	case product.FieldMinStorageTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinStorageTemp(v)
		return nil
	case product.FieldMaxStorageTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxStorageTemp(v)
		return nil
	case product.FieldShelfLife:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShelfLife(v)
		return nil
	case product.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case product.FieldProductCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductCategoryID(v)
		return nil
	case product.FieldTypeOfPackagingID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeOfPackagingID(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, product.FieldWeight)
	}
	if m.addmin_storage_temp != nil {
		fields = append(fields, product.FieldMinStorageTemp)
	}
	if m.addmax_storage_temp != nil {
		fields = append(fields, product.FieldMaxStorageTemp)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldWeight:
		return m.AddedWeight()
	case product.FieldMinStorageTemp:
		return m.AddedMinStorageTemp()
	case product.FieldMaxStorageTemp:
		return m.AddedMaxStorageTemp()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case product.FieldMinStorageTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinStorageTemp(v)
		return nil
	case product.FieldMaxStorageTemp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxStorageTemp(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldName) {
		fields = append(fields, product.FieldName)
	}
	if m.FieldCleared(product.FieldWeight) {
		fields = append(fields, product.FieldWeight)
	}
	if m.FieldCleared(product.FieldProductComposition) {
		fields = append(fields, product.FieldProductComposition)
	}
	if m.FieldCleared(product.FieldMinStorageTemp) {
		fields = append(fields, product.FieldMinStorageTemp)
	}
	if m.FieldCleared(product.FieldMaxStorageTemp) {
		fields = append(fields, product.FieldMaxStorageTemp)
	}
	if m.FieldCleared(product.FieldShelfLife) {
		fields = append(fields, product.FieldShelfLife)
	}
	if m.FieldCleared(product.FieldPicture) {
		fields = append(fields, product.FieldPicture)
	}
	if m.FieldCleared(product.FieldProductCategoryID) {
		fields = append(fields, product.FieldProductCategoryID)
	}
	if m.FieldCleared(product.FieldTypeOfPackagingID) {
		fields = append(fields, product.FieldTypeOfPackagingID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldName:
		m.ClearName()
		return nil
	case product.FieldWeight:
		m.ClearWeight()
		return nil
	case product.FieldProductComposition:
		m.ClearProductComposition()
		return nil
	case product.FieldMinStorageTemp:
		m.ClearMinStorageTemp()
		return nil
	case product.FieldMaxStorageTemp:
		m.ClearMaxStorageTemp()
		return nil
	case product.FieldShelfLife:
		m.ClearShelfLife()
		return nil
	case product.FieldPicture:
		m.ClearPicture()
		return nil
	case product.FieldProductCategoryID:
		m.ClearProductCategoryID()
		return nil
	case product.FieldTypeOfPackagingID:
		m.ClearTypeOfPackagingID()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldWeight:
		m.ResetWeight()
		return nil
	case product.FieldProductComposition:
		m.ResetProductComposition()
		return nil
	case product.FieldMinStorageTemp:
		m.ResetMinStorageTemp()
		return nil
	case product.FieldMaxStorageTemp:
		m.ResetMaxStorageTemp()
		return nil
	case product.FieldShelfLife:
		m.ResetShelfLife()
		return nil
	case product.FieldPicture:
		m.ResetPicture()
		return nil
	case product.FieldProductCategoryID:
		m.ResetProductCategoryID()
		return nil
	case product.FieldTypeOfPackagingID:
		m.ResetTypeOfPackagingID()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.order_detail_product != nil {
		edges = append(edges, product.EdgeOrderDetailProduct)
	}
	if m.shopping_cart_product != nil {
		edges = append(edges, product.EdgeShoppingCartProduct)
	}
	if m.product_price_product != nil {
		edges = append(edges, product.EdgeProductPriceProduct)
	}
	if m.product_category != nil {
		edges = append(edges, product.EdgeProductCategory)
	}
	if m.type_of_packaging_product != nil {
		edges = append(edges, product.EdgeTypeOfPackagingProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrderDetailProduct:
		ids := make([]ent.Value, 0, len(m.order_detail_product))
		for id := range m.order_detail_product {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeShoppingCartProduct:
		ids := make([]ent.Value, 0, len(m.shopping_cart_product))
		for id := range m.shopping_cart_product {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductPriceProduct:
		ids := make([]ent.Value, 0, len(m.product_price_product))
		for id := range m.product_price_product {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductCategory:
		if id := m.product_category; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeTypeOfPackagingProduct:
		if id := m.type_of_packaging_product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_detail_product != nil {
		edges = append(edges, product.EdgeOrderDetailProduct)
	}
	if m.removedshopping_cart_product != nil {
		edges = append(edges, product.EdgeShoppingCartProduct)
	}
	if m.removedproduct_price_product != nil {
		edges = append(edges, product.EdgeProductPriceProduct)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeOrderDetailProduct:
		ids := make([]ent.Value, 0, len(m.removedorder_detail_product))
		for id := range m.removedorder_detail_product {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeShoppingCartProduct:
		ids := make([]ent.Value, 0, len(m.removedshopping_cart_product))
		for id := range m.removedshopping_cart_product {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductPriceProduct:
		ids := make([]ent.Value, 0, len(m.removedproduct_price_product))
		for id := range m.removedproduct_price_product {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedorder_detail_product {
		edges = append(edges, product.EdgeOrderDetailProduct)
	}
	if m.clearedshopping_cart_product {
		edges = append(edges, product.EdgeShoppingCartProduct)
	}
	if m.clearedproduct_price_product {
		edges = append(edges, product.EdgeProductPriceProduct)
	}
	if m.clearedproduct_category {
		edges = append(edges, product.EdgeProductCategory)
	}
	if m.clearedtype_of_packaging_product {
		edges = append(edges, product.EdgeTypeOfPackagingProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeOrderDetailProduct:
		return m.clearedorder_detail_product
	case product.EdgeShoppingCartProduct:
		return m.clearedshopping_cart_product
	case product.EdgeProductPriceProduct:
		return m.clearedproduct_price_product
	case product.EdgeProductCategory:
		return m.clearedproduct_category
	case product.EdgeTypeOfPackagingProduct:
		return m.clearedtype_of_packaging_product
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeProductCategory:
		m.ClearProductCategory()
		return nil
	case product.EdgeTypeOfPackagingProduct:
		m.ClearTypeOfPackagingProduct()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeOrderDetailProduct:
		m.ResetOrderDetailProduct()
		return nil
	case product.EdgeShoppingCartProduct:
		m.ResetShoppingCartProduct()
		return nil
	case product.EdgeProductPriceProduct:
		m.ResetProductPriceProduct()
		return nil
	case product.EdgeProductCategory:
		m.ResetProductCategory()
		return nil
	case product.EdgeTypeOfPackagingProduct:
		m.ResetTypeOfPackagingProduct()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductCategoryMutation represents an operation that mutates the ProductCategory nodes in the graph.
type ProductCategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	clearedFields   map[string]struct{}
	category        map[int]struct{}
	removedcategory map[int]struct{}
	clearedcategory bool
	done            bool
	oldValue        func(context.Context) (*ProductCategory, error)
	predicates      []predicate.ProductCategory
}

var _ ent.Mutation = (*ProductCategoryMutation)(nil)

// productcategoryOption allows management of the mutation configuration using functional options.
type productcategoryOption func(*ProductCategoryMutation)

// newProductCategoryMutation creates new mutation for the ProductCategory entity.
func newProductCategoryMutation(c config, op Op, opts ...productcategoryOption) *ProductCategoryMutation {
	m := &ProductCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeProductCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductCategoryID sets the ID field of the mutation.
func withProductCategoryID(id int) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductCategory
		)
		m.oldValue = func(ctx context.Context) (*ProductCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductCategory sets the old ProductCategory of the mutation.
func withProductCategory(node *ProductCategory) productcategoryOption {
	return func(m *ProductCategoryMutation) {
		m.oldValue = func(context.Context) (*ProductCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ProductCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductCategory entity.
// If the ProductCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *ProductCategoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[productcategory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *ProductCategoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[productcategory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *ProductCategoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, productcategory.FieldName)
}

// AddCategoryIDs adds the "category" edge to the Product entity by ids.
func (m *ProductCategoryMutation) AddCategoryIDs(ids ...int) {
	if m.category == nil {
		m.category = make(map[int]struct{})
	}
	for i := range ids {
		m.category[ids[i]] = struct{}{}
	}
}

// ClearCategory clears the "category" edge to the Product entity.
func (m *ProductCategoryMutation) ClearCategory() {
	m.clearedcategory = true
}

// CategoryCleared reports if the "category" edge to the Product entity was cleared.
func (m *ProductCategoryMutation) CategoryCleared() bool {
	return m.clearedcategory
}

// RemoveCategoryIDs removes the "category" edge to the Product entity by IDs.
func (m *ProductCategoryMutation) RemoveCategoryIDs(ids ...int) {
	if m.removedcategory == nil {
		m.removedcategory = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.category, ids[i])
		m.removedcategory[ids[i]] = struct{}{}
	}
}

// RemovedCategory returns the removed IDs of the "category" edge to the Product entity.
func (m *ProductCategoryMutation) RemovedCategoryIDs() (ids []int) {
	for id := range m.removedcategory {
		ids = append(ids, id)
	}
	return
}

// CategoryIDs returns the "category" edge IDs in the mutation.
func (m *ProductCategoryMutation) CategoryIDs() (ids []int) {
	for id := range m.category {
		ids = append(ids, id)
	}
	return
}

// ResetCategory resets all changes to the "category" edge.
func (m *ProductCategoryMutation) ResetCategory() {
	m.category = nil
	m.clearedcategory = false
	m.removedcategory = nil
}

// Where appends a list predicates to the ProductCategoryMutation builder.
func (m *ProductCategoryMutation) Where(ps ...predicate.ProductCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductCategory).
func (m *ProductCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, productcategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productcategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productcategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ProductCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productcategory.FieldName) {
		fields = append(fields, productcategory.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ClearField(name string) error {
	switch name {
	case productcategory.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductCategoryMutation) ResetField(name string) error {
	switch name {
	case productcategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.category != nil {
		edges = append(edges, productcategory.EdgeCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.category))
		for id := range m.category {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcategory != nil {
		edges = append(edges, productcategory.EdgeCategory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productcategory.EdgeCategory:
		ids := make([]ent.Value, 0, len(m.removedcategory))
		for id := range m.removedcategory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategory {
		edges = append(edges, productcategory.EdgeCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case productcategory.EdgeCategory:
		return m.clearedcategory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductCategoryMutation) ResetEdge(name string) error {
	switch name {
	case productcategory.EdgeCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown ProductCategory edge %s", name)
}

// ProductPriceMutation represents an operation that mutates the ProductPrice nodes in the graph.
type ProductPriceMutation struct {
	config
	op                Op
	typ               string
	id                *int
	modification_date *time.Time
	new_price         *float64
	addnew_price      *float64
	clearedFields     map[string]struct{}
	product           *int
	clearedproduct    bool
	done              bool
	oldValue          func(context.Context) (*ProductPrice, error)
	predicates        []predicate.ProductPrice
}

var _ ent.Mutation = (*ProductPriceMutation)(nil)

// productpriceOption allows management of the mutation configuration using functional options.
type productpriceOption func(*ProductPriceMutation)

// newProductPriceMutation creates new mutation for the ProductPrice entity.
func newProductPriceMutation(c config, op Op, opts ...productpriceOption) *ProductPriceMutation {
	m := &ProductPriceMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPriceID sets the ID field of the mutation.
func withProductPriceID(id int) productpriceOption {
	return func(m *ProductPriceMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPrice
		)
		m.oldValue = func(ctx context.Context) (*ProductPrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPrice sets the old ProductPrice of the mutation.
func withProductPrice(node *ProductPrice) productpriceOption {
	return func(m *ProductPriceMutation) {
		m.oldValue = func(context.Context) (*ProductPrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPriceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductPriceMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductPrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModificationDate sets the "modification_date" field.
func (m *ProductPriceMutation) SetModificationDate(t time.Time) {
	m.modification_date = &t
}

// ModificationDate returns the value of the "modification_date" field in the mutation.
func (m *ProductPriceMutation) ModificationDate() (r time.Time, exists bool) {
	v := m.modification_date
	if v == nil {
		return
	}
	return *v, true
}

// OldModificationDate returns the old "modification_date" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldModificationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModificationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModificationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModificationDate: %w", err)
	}
	return oldValue.ModificationDate, nil
}

// ClearModificationDate clears the value of the "modification_date" field.
func (m *ProductPriceMutation) ClearModificationDate() {
	m.modification_date = nil
	m.clearedFields[productprice.FieldModificationDate] = struct{}{}
}

// ModificationDateCleared returns if the "modification_date" field was cleared in this mutation.
func (m *ProductPriceMutation) ModificationDateCleared() bool {
	_, ok := m.clearedFields[productprice.FieldModificationDate]
	return ok
}

// ResetModificationDate resets all changes to the "modification_date" field.
func (m *ProductPriceMutation) ResetModificationDate() {
	m.modification_date = nil
	delete(m.clearedFields, productprice.FieldModificationDate)
}

// SetNewPrice sets the "new_price" field.
func (m *ProductPriceMutation) SetNewPrice(f float64) {
	m.new_price = &f
	m.addnew_price = nil
}

// NewPrice returns the value of the "new_price" field in the mutation.
func (m *ProductPriceMutation) NewPrice() (r float64, exists bool) {
	v := m.new_price
	if v == nil {
		return
	}
	return *v, true
}

// OldNewPrice returns the old "new_price" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldNewPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewPrice: %w", err)
	}
	return oldValue.NewPrice, nil
}

// AddNewPrice adds f to the "new_price" field.
func (m *ProductPriceMutation) AddNewPrice(f float64) {
	if m.addnew_price != nil {
		*m.addnew_price += f
	} else {
		m.addnew_price = &f
	}
}

// AddedNewPrice returns the value that was added to the "new_price" field in this mutation.
func (m *ProductPriceMutation) AddedNewPrice() (r float64, exists bool) {
	v := m.addnew_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearNewPrice clears the value of the "new_price" field.
func (m *ProductPriceMutation) ClearNewPrice() {
	m.new_price = nil
	m.addnew_price = nil
	m.clearedFields[productprice.FieldNewPrice] = struct{}{}
}

// NewPriceCleared returns if the "new_price" field was cleared in this mutation.
func (m *ProductPriceMutation) NewPriceCleared() bool {
	_, ok := m.clearedFields[productprice.FieldNewPrice]
	return ok
}

// ResetNewPrice resets all changes to the "new_price" field.
func (m *ProductPriceMutation) ResetNewPrice() {
	m.new_price = nil
	m.addnew_price = nil
	delete(m.clearedFields, productprice.FieldNewPrice)
}

// SetProductID sets the "product_id" field.
func (m *ProductPriceMutation) SetProductID(i int) {
	m.product = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ProductPriceMutation) ProductID() (r int, exists bool) {
	v := m.product
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ProductPrice entity.
// If the ProductPrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPriceMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ProductPriceMutation) ClearProductID() {
	m.product = nil
	m.clearedFields[productprice.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ProductPriceMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[productprice.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ProductPriceMutation) ResetProductID() {
	m.product = nil
	delete(m.clearedFields, productprice.FieldProductID)
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductPriceMutation) ClearProduct() {
	m.clearedproduct = true
	m.clearedFields[productprice.FieldProductID] = struct{}{}
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductPriceMutation) ProductCleared() bool {
	return m.ProductIDCleared() || m.clearedproduct
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductPriceMutation) ProductIDs() (ids []int) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductPriceMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// Where appends a list predicates to the ProductPriceMutation builder.
func (m *ProductPriceMutation) Where(ps ...predicate.ProductPrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductPriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductPriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductPrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductPriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductPriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductPrice).
func (m *ProductPriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPriceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.modification_date != nil {
		fields = append(fields, productprice.FieldModificationDate)
	}
	if m.new_price != nil {
		fields = append(fields, productprice.FieldNewPrice)
	}
	if m.product != nil {
		fields = append(fields, productprice.FieldProductID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productprice.FieldModificationDate:
		return m.ModificationDate()
	case productprice.FieldNewPrice:
		return m.NewPrice()
	case productprice.FieldProductID:
		return m.ProductID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productprice.FieldModificationDate:
		return m.OldModificationDate(ctx)
	case productprice.FieldNewPrice:
		return m.OldNewPrice(ctx)
	case productprice.FieldProductID:
		return m.OldProductID(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productprice.FieldModificationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModificationDate(v)
		return nil
	case productprice.FieldNewPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewPrice(v)
		return nil
	case productprice.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPriceMutation) AddedFields() []string {
	var fields []string
	if m.addnew_price != nil {
		fields = append(fields, productprice.FieldNewPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productprice.FieldNewPrice:
		return m.AddedNewPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productprice.FieldNewPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNewPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productprice.FieldModificationDate) {
		fields = append(fields, productprice.FieldModificationDate)
	}
	if m.FieldCleared(productprice.FieldNewPrice) {
		fields = append(fields, productprice.FieldNewPrice)
	}
	if m.FieldCleared(productprice.FieldProductID) {
		fields = append(fields, productprice.FieldProductID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPriceMutation) ClearField(name string) error {
	switch name {
	case productprice.FieldModificationDate:
		m.ClearModificationDate()
		return nil
	case productprice.FieldNewPrice:
		m.ClearNewPrice()
		return nil
	case productprice.FieldProductID:
		m.ClearProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPriceMutation) ResetField(name string) error {
	switch name {
	case productprice.FieldModificationDate:
		m.ResetModificationDate()
		return nil
	case productprice.FieldNewPrice:
		m.ResetNewPrice()
		return nil
	case productprice.FieldProductID:
		m.ResetProductID()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.product != nil {
		edges = append(edges, productprice.EdgeProduct)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productprice.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproduct {
		edges = append(edges, productprice.EdgeProduct)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPriceMutation) EdgeCleared(name string) bool {
	switch name {
	case productprice.EdgeProduct:
		return m.clearedproduct
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPriceMutation) ClearEdge(name string) error {
	switch name {
	case productprice.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPriceMutation) ResetEdge(name string) error {
	switch name {
	case productprice.EdgeProduct:
		m.ResetProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductPrice edge %s", name)
}

// ShoppingCartMutation represents an operation that mutates the ShoppingCart nodes in the graph.
type ShoppingCartMutation struct {
	config
	op              Op
	typ             string
	id              *int
	quantity        *int
	addquantity     *int
	clearedFields   map[string]struct{}
	products        *int
	clearedproducts bool
	users           *int
	clearedusers    bool
	done            bool
	oldValue        func(context.Context) (*ShoppingCart, error)
	predicates      []predicate.ShoppingCart
}

var _ ent.Mutation = (*ShoppingCartMutation)(nil)

// shoppingcartOption allows management of the mutation configuration using functional options.
type shoppingcartOption func(*ShoppingCartMutation)

// newShoppingCartMutation creates new mutation for the ShoppingCart entity.
func newShoppingCartMutation(c config, op Op, opts ...shoppingcartOption) *ShoppingCartMutation {
	m := &ShoppingCartMutation{
		config:        c,
		op:            op,
		typ:           TypeShoppingCart,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShoppingCartID sets the ID field of the mutation.
func withShoppingCartID(id int) shoppingcartOption {
	return func(m *ShoppingCartMutation) {
		var (
			err   error
			once  sync.Once
			value *ShoppingCart
		)
		m.oldValue = func(ctx context.Context) (*ShoppingCart, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShoppingCart.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShoppingCart sets the old ShoppingCart of the mutation.
func withShoppingCart(node *ShoppingCart) shoppingcartOption {
	return func(m *ShoppingCartMutation) {
		m.oldValue = func(context.Context) (*ShoppingCart, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShoppingCartMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShoppingCartMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShoppingCartMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShoppingCartMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShoppingCart.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetQuantity sets the "quantity" field.
func (m *ShoppingCartMutation) SetQuantity(i int) {
	m.quantity = &i
	m.addquantity = nil
}

// Quantity returns the value of the "quantity" field in the mutation.
func (m *ShoppingCartMutation) Quantity() (r int, exists bool) {
	v := m.quantity
	if v == nil {
		return
	}
	return *v, true
}

// OldQuantity returns the old "quantity" field's value of the ShoppingCart entity.
// If the ShoppingCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShoppingCartMutation) OldQuantity(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuantity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuantity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuantity: %w", err)
	}
	return oldValue.Quantity, nil
}

// AddQuantity adds i to the "quantity" field.
func (m *ShoppingCartMutation) AddQuantity(i int) {
	if m.addquantity != nil {
		*m.addquantity += i
	} else {
		m.addquantity = &i
	}
}

// AddedQuantity returns the value that was added to the "quantity" field in this mutation.
func (m *ShoppingCartMutation) AddedQuantity() (r int, exists bool) {
	v := m.addquantity
	if v == nil {
		return
	}
	return *v, true
}

// ClearQuantity clears the value of the "quantity" field.
func (m *ShoppingCartMutation) ClearQuantity() {
	m.quantity = nil
	m.addquantity = nil
	m.clearedFields[shoppingcart.FieldQuantity] = struct{}{}
}

// QuantityCleared returns if the "quantity" field was cleared in this mutation.
func (m *ShoppingCartMutation) QuantityCleared() bool {
	_, ok := m.clearedFields[shoppingcart.FieldQuantity]
	return ok
}

// ResetQuantity resets all changes to the "quantity" field.
func (m *ShoppingCartMutation) ResetQuantity() {
	m.quantity = nil
	m.addquantity = nil
	delete(m.clearedFields, shoppingcart.FieldQuantity)
}

// SetProductID sets the "product_id" field.
func (m *ShoppingCartMutation) SetProductID(i int) {
	m.products = &i
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *ShoppingCartMutation) ProductID() (r int, exists bool) {
	v := m.products
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the ShoppingCart entity.
// If the ShoppingCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShoppingCartMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// ClearProductID clears the value of the "product_id" field.
func (m *ShoppingCartMutation) ClearProductID() {
	m.products = nil
	m.clearedFields[shoppingcart.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *ShoppingCartMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[shoppingcart.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *ShoppingCartMutation) ResetProductID() {
	m.products = nil
	delete(m.clearedFields, shoppingcart.FieldProductID)
}

// SetUserID sets the "user_id" field.
func (m *ShoppingCartMutation) SetUserID(i int) {
	m.users = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ShoppingCartMutation) UserID() (r int, exists bool) {
	v := m.users
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the ShoppingCart entity.
// If the ShoppingCart object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShoppingCartMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ShoppingCartMutation) ClearUserID() {
	m.users = nil
	m.clearedFields[shoppingcart.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ShoppingCartMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[shoppingcart.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ShoppingCartMutation) ResetUserID() {
	m.users = nil
	delete(m.clearedFields, shoppingcart.FieldUserID)
}

// SetProductsID sets the "products" edge to the Product entity by id.
func (m *ShoppingCartMutation) SetProductsID(id int) {
	m.products = &id
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ShoppingCartMutation) ClearProducts() {
	m.clearedproducts = true
	m.clearedFields[shoppingcart.FieldProductID] = struct{}{}
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ShoppingCartMutation) ProductsCleared() bool {
	return m.ProductIDCleared() || m.clearedproducts
}

// ProductsID returns the "products" edge ID in the mutation.
func (m *ShoppingCartMutation) ProductsID() (id int, exists bool) {
	if m.products != nil {
		return *m.products, true
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsID instead. It exists only for internal usage by the builders.
func (m *ShoppingCartMutation) ProductsIDs() (ids []int) {
	if id := m.products; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ShoppingCartMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *ShoppingCartMutation) SetUsersID(id int) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *ShoppingCartMutation) ClearUsers() {
	m.clearedusers = true
	m.clearedFields[shoppingcart.FieldUserID] = struct{}{}
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *ShoppingCartMutation) UsersCleared() bool {
	return m.UserIDCleared() || m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *ShoppingCartMutation) UsersID() (id int, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *ShoppingCartMutation) UsersIDs() (ids []int) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *ShoppingCartMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the ShoppingCartMutation builder.
func (m *ShoppingCartMutation) Where(ps ...predicate.ShoppingCart) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShoppingCartMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShoppingCartMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShoppingCart, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShoppingCartMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShoppingCartMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShoppingCart).
func (m *ShoppingCartMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShoppingCartMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.quantity != nil {
		fields = append(fields, shoppingcart.FieldQuantity)
	}
	if m.products != nil {
		fields = append(fields, shoppingcart.FieldProductID)
	}
	if m.users != nil {
		fields = append(fields, shoppingcart.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShoppingCartMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shoppingcart.FieldQuantity:
		return m.Quantity()
	case shoppingcart.FieldProductID:
		return m.ProductID()
	case shoppingcart.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShoppingCartMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shoppingcart.FieldQuantity:
		return m.OldQuantity(ctx)
	case shoppingcart.FieldProductID:
		return m.OldProductID(ctx)
	case shoppingcart.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown ShoppingCart field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShoppingCartMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shoppingcart.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuantity(v)
		return nil
	case shoppingcart.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case shoppingcart.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShoppingCartMutation) AddedFields() []string {
	var fields []string
	if m.addquantity != nil {
		fields = append(fields, shoppingcart.FieldQuantity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShoppingCartMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shoppingcart.FieldQuantity:
		return m.AddedQuantity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShoppingCartMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shoppingcart.FieldQuantity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuantity(v)
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShoppingCartMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shoppingcart.FieldQuantity) {
		fields = append(fields, shoppingcart.FieldQuantity)
	}
	if m.FieldCleared(shoppingcart.FieldProductID) {
		fields = append(fields, shoppingcart.FieldProductID)
	}
	if m.FieldCleared(shoppingcart.FieldUserID) {
		fields = append(fields, shoppingcart.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShoppingCartMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShoppingCartMutation) ClearField(name string) error {
	switch name {
	case shoppingcart.FieldQuantity:
		m.ClearQuantity()
		return nil
	case shoppingcart.FieldProductID:
		m.ClearProductID()
		return nil
	case shoppingcart.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShoppingCartMutation) ResetField(name string) error {
	switch name {
	case shoppingcart.FieldQuantity:
		m.ResetQuantity()
		return nil
	case shoppingcart.FieldProductID:
		m.ResetProductID()
		return nil
	case shoppingcart.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShoppingCartMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.products != nil {
		edges = append(edges, shoppingcart.EdgeProducts)
	}
	if m.users != nil {
		edges = append(edges, shoppingcart.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShoppingCartMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shoppingcart.EdgeProducts:
		if id := m.products; id != nil {
			return []ent.Value{*id}
		}
	case shoppingcart.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShoppingCartMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShoppingCartMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShoppingCartMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedproducts {
		edges = append(edges, shoppingcart.EdgeProducts)
	}
	if m.clearedusers {
		edges = append(edges, shoppingcart.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShoppingCartMutation) EdgeCleared(name string) bool {
	switch name {
	case shoppingcart.EdgeProducts:
		return m.clearedproducts
	case shoppingcart.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShoppingCartMutation) ClearEdge(name string) error {
	switch name {
	case shoppingcart.EdgeProducts:
		m.ClearProducts()
		return nil
	case shoppingcart.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShoppingCartMutation) ResetEdge(name string) error {
	switch name {
	case shoppingcart.EdgeProducts:
		m.ResetProducts()
		return nil
	case shoppingcart.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown ShoppingCart edge %s", name)
}

// TypeOfPackagingMutation represents an operation that mutates the TypeOfPackaging nodes in the graph.
type TypeOfPackagingMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	name                     *string
	clearedFields            map[string]struct{}
	type_of_packaging        map[int]struct{}
	removedtype_of_packaging map[int]struct{}
	clearedtype_of_packaging bool
	done                     bool
	oldValue                 func(context.Context) (*TypeOfPackaging, error)
	predicates               []predicate.TypeOfPackaging
}

var _ ent.Mutation = (*TypeOfPackagingMutation)(nil)

// typeofpackagingOption allows management of the mutation configuration using functional options.
type typeofpackagingOption func(*TypeOfPackagingMutation)

// newTypeOfPackagingMutation creates new mutation for the TypeOfPackaging entity.
func newTypeOfPackagingMutation(c config, op Op, opts ...typeofpackagingOption) *TypeOfPackagingMutation {
	m := &TypeOfPackagingMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeOfPackaging,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeOfPackagingID sets the ID field of the mutation.
func withTypeOfPackagingID(id int) typeofpackagingOption {
	return func(m *TypeOfPackagingMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeOfPackaging
		)
		m.oldValue = func(ctx context.Context) (*TypeOfPackaging, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeOfPackaging.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeOfPackaging sets the old TypeOfPackaging of the mutation.
func withTypeOfPackaging(node *TypeOfPackaging) typeofpackagingOption {
	return func(m *TypeOfPackagingMutation) {
		m.oldValue = func(context.Context) (*TypeOfPackaging, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeOfPackagingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeOfPackagingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TypeOfPackagingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TypeOfPackagingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TypeOfPackaging.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TypeOfPackagingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TypeOfPackagingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TypeOfPackaging entity.
// If the TypeOfPackaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TypeOfPackagingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TypeOfPackagingMutation) ClearName() {
	m.name = nil
	m.clearedFields[typeofpackaging.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TypeOfPackagingMutation) NameCleared() bool {
	_, ok := m.clearedFields[typeofpackaging.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TypeOfPackagingMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, typeofpackaging.FieldName)
}

// AddTypeOfPackagingIDs adds the "type_of_packaging" edge to the Product entity by ids.
func (m *TypeOfPackagingMutation) AddTypeOfPackagingIDs(ids ...int) {
	if m.type_of_packaging == nil {
		m.type_of_packaging = make(map[int]struct{})
	}
	for i := range ids {
		m.type_of_packaging[ids[i]] = struct{}{}
	}
}

// ClearTypeOfPackaging clears the "type_of_packaging" edge to the Product entity.
func (m *TypeOfPackagingMutation) ClearTypeOfPackaging() {
	m.clearedtype_of_packaging = true
}

// TypeOfPackagingCleared reports if the "type_of_packaging" edge to the Product entity was cleared.
func (m *TypeOfPackagingMutation) TypeOfPackagingCleared() bool {
	return m.clearedtype_of_packaging
}

// RemoveTypeOfPackagingIDs removes the "type_of_packaging" edge to the Product entity by IDs.
func (m *TypeOfPackagingMutation) RemoveTypeOfPackagingIDs(ids ...int) {
	if m.removedtype_of_packaging == nil {
		m.removedtype_of_packaging = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.type_of_packaging, ids[i])
		m.removedtype_of_packaging[ids[i]] = struct{}{}
	}
}

// RemovedTypeOfPackaging returns the removed IDs of the "type_of_packaging" edge to the Product entity.
func (m *TypeOfPackagingMutation) RemovedTypeOfPackagingIDs() (ids []int) {
	for id := range m.removedtype_of_packaging {
		ids = append(ids, id)
	}
	return
}

// TypeOfPackagingIDs returns the "type_of_packaging" edge IDs in the mutation.
func (m *TypeOfPackagingMutation) TypeOfPackagingIDs() (ids []int) {
	for id := range m.type_of_packaging {
		ids = append(ids, id)
	}
	return
}

// ResetTypeOfPackaging resets all changes to the "type_of_packaging" edge.
func (m *TypeOfPackagingMutation) ResetTypeOfPackaging() {
	m.type_of_packaging = nil
	m.clearedtype_of_packaging = false
	m.removedtype_of_packaging = nil
}

// Where appends a list predicates to the TypeOfPackagingMutation builder.
func (m *TypeOfPackagingMutation) Where(ps ...predicate.TypeOfPackaging) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TypeOfPackagingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TypeOfPackagingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TypeOfPackaging, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TypeOfPackagingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TypeOfPackagingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TypeOfPackaging).
func (m *TypeOfPackagingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TypeOfPackagingMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, typeofpackaging.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TypeOfPackagingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typeofpackaging.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TypeOfPackagingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typeofpackaging.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TypeOfPackaging field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeOfPackagingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typeofpackaging.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TypeOfPackaging field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TypeOfPackagingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TypeOfPackagingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TypeOfPackagingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeOfPackaging numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TypeOfPackagingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(typeofpackaging.FieldName) {
		fields = append(fields, typeofpackaging.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TypeOfPackagingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeOfPackagingMutation) ClearField(name string) error {
	switch name {
	case typeofpackaging.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown TypeOfPackaging nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TypeOfPackagingMutation) ResetField(name string) error {
	switch name {
	case typeofpackaging.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TypeOfPackaging field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TypeOfPackagingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.type_of_packaging != nil {
		edges = append(edges, typeofpackaging.EdgeTypeOfPackaging)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TypeOfPackagingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typeofpackaging.EdgeTypeOfPackaging:
		ids := make([]ent.Value, 0, len(m.type_of_packaging))
		for id := range m.type_of_packaging {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TypeOfPackagingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtype_of_packaging != nil {
		edges = append(edges, typeofpackaging.EdgeTypeOfPackaging)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TypeOfPackagingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typeofpackaging.EdgeTypeOfPackaging:
		ids := make([]ent.Value, 0, len(m.removedtype_of_packaging))
		for id := range m.removedtype_of_packaging {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TypeOfPackagingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtype_of_packaging {
		edges = append(edges, typeofpackaging.EdgeTypeOfPackaging)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TypeOfPackagingMutation) EdgeCleared(name string) bool {
	switch name {
	case typeofpackaging.EdgeTypeOfPackaging:
		return m.clearedtype_of_packaging
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TypeOfPackagingMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeOfPackaging unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TypeOfPackagingMutation) ResetEdge(name string) error {
	switch name {
	case typeofpackaging.EdgeTypeOfPackaging:
		m.ResetTypeOfPackaging()
		return nil
	}
	return fmt.Errorf("unknown TypeOfPackaging edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	full_name                 *string
	username                  *string
	email                     *string
	password_hash             *string
	phone_number              *string
	clearedFields             map[string]struct{}
	user_category             *int
	cleareduser_category      bool
	shopping_cart_user        map[int]struct{}
	removedshopping_cart_user map[int]struct{}
	clearedshopping_cart_user bool
	user_token_user           map[int]struct{}
	removeduser_token_user    map[int]struct{}
	cleareduser_token_user    bool
	order_user                map[int]struct{}
	removedorder_user         map[int]struct{}
	clearedorder_user         bool
	addresses                 map[int]struct{}
	removedaddresses          map[int]struct{}
	clearedaddresses          bool
	user_chat                 map[int]struct{}
	removeduser_chat          map[int]struct{}
	cleareduser_chat          bool
	user_card                 map[int]struct{}
	removeduser_card          map[int]struct{}
	cleareduser_card          bool
	user_message              map[int]struct{}
	removeduser_message       map[int]struct{}
	cleareduser_message       bool
	done                      bool
	oldValue                  func(context.Context) (*User, error)
	predicates                []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ClearFullName clears the value of the "full_name" field.
func (m *UserMutation) ClearFullName() {
	m.full_name = nil
	m.clearedFields[user.FieldFullName] = struct{}{}
}

// FullNameCleared returns if the "full_name" field was cleared in this mutation.
func (m *UserMutation) FullNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFullName]
	return ok
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
	delete(m.clearedFields, user.FieldFullName)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *UserMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[user.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *UserMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, user.FieldUsername)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ClearPasswordHash clears the value of the "password_hash" field.
func (m *UserMutation) ClearPasswordHash() {
	m.password_hash = nil
	m.clearedFields[user.FieldPasswordHash] = struct{}{}
}

// PasswordHashCleared returns if the "password_hash" field was cleared in this mutation.
func (m *UserMutation) PasswordHashCleared() bool {
	_, ok := m.clearedFields[user.FieldPasswordHash]
	return ok
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
	delete(m.clearedFields, user.FieldPasswordHash)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetUserCategoryID sets the "user_category_id" field.
func (m *UserMutation) SetUserCategoryID(i int) {
	m.user_category = &i
}

// UserCategoryID returns the value of the "user_category_id" field in the mutation.
func (m *UserMutation) UserCategoryID() (r int, exists bool) {
	v := m.user_category
	if v == nil {
		return
	}
	return *v, true
}

// OldUserCategoryID returns the old "user_category_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUserCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserCategoryID: %w", err)
	}
	return oldValue.UserCategoryID, nil
}

// ClearUserCategoryID clears the value of the "user_category_id" field.
func (m *UserMutation) ClearUserCategoryID() {
	m.user_category = nil
	m.clearedFields[user.FieldUserCategoryID] = struct{}{}
}

// UserCategoryIDCleared returns if the "user_category_id" field was cleared in this mutation.
func (m *UserMutation) UserCategoryIDCleared() bool {
	_, ok := m.clearedFields[user.FieldUserCategoryID]
	return ok
}

// ResetUserCategoryID resets all changes to the "user_category_id" field.
func (m *UserMutation) ResetUserCategoryID() {
	m.user_category = nil
	delete(m.clearedFields, user.FieldUserCategoryID)
}

// ClearUserCategory clears the "user_category" edge to the UserCategory entity.
func (m *UserMutation) ClearUserCategory() {
	m.cleareduser_category = true
	m.clearedFields[user.FieldUserCategoryID] = struct{}{}
}

// UserCategoryCleared reports if the "user_category" edge to the UserCategory entity was cleared.
func (m *UserMutation) UserCategoryCleared() bool {
	return m.UserCategoryIDCleared() || m.cleareduser_category
}

// UserCategoryIDs returns the "user_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserCategoryID instead. It exists only for internal usage by the builders.
func (m *UserMutation) UserCategoryIDs() (ids []int) {
	if id := m.user_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserCategory resets all changes to the "user_category" edge.
func (m *UserMutation) ResetUserCategory() {
	m.user_category = nil
	m.cleareduser_category = false
}

// AddShoppingCartUserIDs adds the "shopping_cart_user" edge to the ShoppingCart entity by ids.
func (m *UserMutation) AddShoppingCartUserIDs(ids ...int) {
	if m.shopping_cart_user == nil {
		m.shopping_cart_user = make(map[int]struct{})
	}
	for i := range ids {
		m.shopping_cart_user[ids[i]] = struct{}{}
	}
}

// ClearShoppingCartUser clears the "shopping_cart_user" edge to the ShoppingCart entity.
func (m *UserMutation) ClearShoppingCartUser() {
	m.clearedshopping_cart_user = true
}

// ShoppingCartUserCleared reports if the "shopping_cart_user" edge to the ShoppingCart entity was cleared.
func (m *UserMutation) ShoppingCartUserCleared() bool {
	return m.clearedshopping_cart_user
}

// RemoveShoppingCartUserIDs removes the "shopping_cart_user" edge to the ShoppingCart entity by IDs.
func (m *UserMutation) RemoveShoppingCartUserIDs(ids ...int) {
	if m.removedshopping_cart_user == nil {
		m.removedshopping_cart_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.shopping_cart_user, ids[i])
		m.removedshopping_cart_user[ids[i]] = struct{}{}
	}
}

// RemovedShoppingCartUser returns the removed IDs of the "shopping_cart_user" edge to the ShoppingCart entity.
func (m *UserMutation) RemovedShoppingCartUserIDs() (ids []int) {
	for id := range m.removedshopping_cart_user {
		ids = append(ids, id)
	}
	return
}

// ShoppingCartUserIDs returns the "shopping_cart_user" edge IDs in the mutation.
func (m *UserMutation) ShoppingCartUserIDs() (ids []int) {
	for id := range m.shopping_cart_user {
		ids = append(ids, id)
	}
	return
}

// ResetShoppingCartUser resets all changes to the "shopping_cart_user" edge.
func (m *UserMutation) ResetShoppingCartUser() {
	m.shopping_cart_user = nil
	m.clearedshopping_cart_user = false
	m.removedshopping_cart_user = nil
}

// AddUserTokenUserIDs adds the "user_token_user" edge to the UserToken entity by ids.
func (m *UserMutation) AddUserTokenUserIDs(ids ...int) {
	if m.user_token_user == nil {
		m.user_token_user = make(map[int]struct{})
	}
	for i := range ids {
		m.user_token_user[ids[i]] = struct{}{}
	}
}

// ClearUserTokenUser clears the "user_token_user" edge to the UserToken entity.
func (m *UserMutation) ClearUserTokenUser() {
	m.cleareduser_token_user = true
}

// UserTokenUserCleared reports if the "user_token_user" edge to the UserToken entity was cleared.
func (m *UserMutation) UserTokenUserCleared() bool {
	return m.cleareduser_token_user
}

// RemoveUserTokenUserIDs removes the "user_token_user" edge to the UserToken entity by IDs.
func (m *UserMutation) RemoveUserTokenUserIDs(ids ...int) {
	if m.removeduser_token_user == nil {
		m.removeduser_token_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_token_user, ids[i])
		m.removeduser_token_user[ids[i]] = struct{}{}
	}
}

// RemovedUserTokenUser returns the removed IDs of the "user_token_user" edge to the UserToken entity.
func (m *UserMutation) RemovedUserTokenUserIDs() (ids []int) {
	for id := range m.removeduser_token_user {
		ids = append(ids, id)
	}
	return
}

// UserTokenUserIDs returns the "user_token_user" edge IDs in the mutation.
func (m *UserMutation) UserTokenUserIDs() (ids []int) {
	for id := range m.user_token_user {
		ids = append(ids, id)
	}
	return
}

// ResetUserTokenUser resets all changes to the "user_token_user" edge.
func (m *UserMutation) ResetUserTokenUser() {
	m.user_token_user = nil
	m.cleareduser_token_user = false
	m.removeduser_token_user = nil
}

// AddOrderUserIDs adds the "order_user" edge to the Order entity by ids.
func (m *UserMutation) AddOrderUserIDs(ids ...int) {
	if m.order_user == nil {
		m.order_user = make(map[int]struct{})
	}
	for i := range ids {
		m.order_user[ids[i]] = struct{}{}
	}
}

// ClearOrderUser clears the "order_user" edge to the Order entity.
func (m *UserMutation) ClearOrderUser() {
	m.clearedorder_user = true
}

// OrderUserCleared reports if the "order_user" edge to the Order entity was cleared.
func (m *UserMutation) OrderUserCleared() bool {
	return m.clearedorder_user
}

// RemoveOrderUserIDs removes the "order_user" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderUserIDs(ids ...int) {
	if m.removedorder_user == nil {
		m.removedorder_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.order_user, ids[i])
		m.removedorder_user[ids[i]] = struct{}{}
	}
}

// RemovedOrderUser returns the removed IDs of the "order_user" edge to the Order entity.
func (m *UserMutation) RemovedOrderUserIDs() (ids []int) {
	for id := range m.removedorder_user {
		ids = append(ids, id)
	}
	return
}

// OrderUserIDs returns the "order_user" edge IDs in the mutation.
func (m *UserMutation) OrderUserIDs() (ids []int) {
	for id := range m.order_user {
		ids = append(ids, id)
	}
	return
}

// ResetOrderUser resets all changes to the "order_user" edge.
func (m *UserMutation) ResetOrderUser() {
	m.order_user = nil
	m.clearedorder_user = false
	m.removedorder_user = nil
}

// AddAddressIDs adds the "addresses" edge to the Address entity by ids.
func (m *UserMutation) AddAddressIDs(ids ...int) {
	if m.addresses == nil {
		m.addresses = make(map[int]struct{})
	}
	for i := range ids {
		m.addresses[ids[i]] = struct{}{}
	}
}

// ClearAddresses clears the "addresses" edge to the Address entity.
func (m *UserMutation) ClearAddresses() {
	m.clearedaddresses = true
}

// AddressesCleared reports if the "addresses" edge to the Address entity was cleared.
func (m *UserMutation) AddressesCleared() bool {
	return m.clearedaddresses
}

// RemoveAddressIDs removes the "addresses" edge to the Address entity by IDs.
func (m *UserMutation) RemoveAddressIDs(ids ...int) {
	if m.removedaddresses == nil {
		m.removedaddresses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.addresses, ids[i])
		m.removedaddresses[ids[i]] = struct{}{}
	}
}

// RemovedAddresses returns the removed IDs of the "addresses" edge to the Address entity.
func (m *UserMutation) RemovedAddressesIDs() (ids []int) {
	for id := range m.removedaddresses {
		ids = append(ids, id)
	}
	return
}

// AddressesIDs returns the "addresses" edge IDs in the mutation.
func (m *UserMutation) AddressesIDs() (ids []int) {
	for id := range m.addresses {
		ids = append(ids, id)
	}
	return
}

// ResetAddresses resets all changes to the "addresses" edge.
func (m *UserMutation) ResetAddresses() {
	m.addresses = nil
	m.clearedaddresses = false
	m.removedaddresses = nil
}

// AddUserChatIDs adds the "user_chat" edge to the Chat entity by ids.
func (m *UserMutation) AddUserChatIDs(ids ...int) {
	if m.user_chat == nil {
		m.user_chat = make(map[int]struct{})
	}
	for i := range ids {
		m.user_chat[ids[i]] = struct{}{}
	}
}

// ClearUserChat clears the "user_chat" edge to the Chat entity.
func (m *UserMutation) ClearUserChat() {
	m.cleareduser_chat = true
}

// UserChatCleared reports if the "user_chat" edge to the Chat entity was cleared.
func (m *UserMutation) UserChatCleared() bool {
	return m.cleareduser_chat
}

// RemoveUserChatIDs removes the "user_chat" edge to the Chat entity by IDs.
func (m *UserMutation) RemoveUserChatIDs(ids ...int) {
	if m.removeduser_chat == nil {
		m.removeduser_chat = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_chat, ids[i])
		m.removeduser_chat[ids[i]] = struct{}{}
	}
}

// RemovedUserChat returns the removed IDs of the "user_chat" edge to the Chat entity.
func (m *UserMutation) RemovedUserChatIDs() (ids []int) {
	for id := range m.removeduser_chat {
		ids = append(ids, id)
	}
	return
}

// UserChatIDs returns the "user_chat" edge IDs in the mutation.
func (m *UserMutation) UserChatIDs() (ids []int) {
	for id := range m.user_chat {
		ids = append(ids, id)
	}
	return
}

// ResetUserChat resets all changes to the "user_chat" edge.
func (m *UserMutation) ResetUserChat() {
	m.user_chat = nil
	m.cleareduser_chat = false
	m.removeduser_chat = nil
}

// AddUserCardIDs adds the "user_card" edge to the Card entity by ids.
func (m *UserMutation) AddUserCardIDs(ids ...int) {
	if m.user_card == nil {
		m.user_card = make(map[int]struct{})
	}
	for i := range ids {
		m.user_card[ids[i]] = struct{}{}
	}
}

// ClearUserCard clears the "user_card" edge to the Card entity.
func (m *UserMutation) ClearUserCard() {
	m.cleareduser_card = true
}

// UserCardCleared reports if the "user_card" edge to the Card entity was cleared.
func (m *UserMutation) UserCardCleared() bool {
	return m.cleareduser_card
}

// RemoveUserCardIDs removes the "user_card" edge to the Card entity by IDs.
func (m *UserMutation) RemoveUserCardIDs(ids ...int) {
	if m.removeduser_card == nil {
		m.removeduser_card = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_card, ids[i])
		m.removeduser_card[ids[i]] = struct{}{}
	}
}

// RemovedUserCard returns the removed IDs of the "user_card" edge to the Card entity.
func (m *UserMutation) RemovedUserCardIDs() (ids []int) {
	for id := range m.removeduser_card {
		ids = append(ids, id)
	}
	return
}

// UserCardIDs returns the "user_card" edge IDs in the mutation.
func (m *UserMutation) UserCardIDs() (ids []int) {
	for id := range m.user_card {
		ids = append(ids, id)
	}
	return
}

// ResetUserCard resets all changes to the "user_card" edge.
func (m *UserMutation) ResetUserCard() {
	m.user_card = nil
	m.cleareduser_card = false
	m.removeduser_card = nil
}

// AddUserMessageIDs adds the "user_message" edge to the Message entity by ids.
func (m *UserMutation) AddUserMessageIDs(ids ...int) {
	if m.user_message == nil {
		m.user_message = make(map[int]struct{})
	}
	for i := range ids {
		m.user_message[ids[i]] = struct{}{}
	}
}

// ClearUserMessage clears the "user_message" edge to the Message entity.
func (m *UserMutation) ClearUserMessage() {
	m.cleareduser_message = true
}

// UserMessageCleared reports if the "user_message" edge to the Message entity was cleared.
func (m *UserMutation) UserMessageCleared() bool {
	return m.cleareduser_message
}

// RemoveUserMessageIDs removes the "user_message" edge to the Message entity by IDs.
func (m *UserMutation) RemoveUserMessageIDs(ids ...int) {
	if m.removeduser_message == nil {
		m.removeduser_message = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_message, ids[i])
		m.removeduser_message[ids[i]] = struct{}{}
	}
}

// RemovedUserMessage returns the removed IDs of the "user_message" edge to the Message entity.
func (m *UserMutation) RemovedUserMessageIDs() (ids []int) {
	for id := range m.removeduser_message {
		ids = append(ids, id)
	}
	return
}

// UserMessageIDs returns the "user_message" edge IDs in the mutation.
func (m *UserMutation) UserMessageIDs() (ids []int) {
	for id := range m.user_message {
		ids = append(ids, id)
	}
	return
}

// ResetUserMessage resets all changes to the "user_message" edge.
func (m *UserMutation) ResetUserMessage() {
	m.user_message = nil
	m.cleareduser_message = false
	m.removeduser_message = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.user_category != nil {
		fields = append(fields, user.FieldUserCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFullName:
		return m.FullName()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldUserCategoryID:
		return m.UserCategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldUserCategoryID:
		return m.OldUserCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldUserCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFullName) {
		fields = append(fields, user.FieldFullName)
	}
	if m.FieldCleared(user.FieldUsername) {
		fields = append(fields, user.FieldUsername)
	}
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPasswordHash) {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldUserCategoryID) {
		fields = append(fields, user.FieldUserCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFullName:
		m.ClearFullName()
		return nil
	case user.FieldUsername:
		m.ClearUsername()
		return nil
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPasswordHash:
		m.ClearPasswordHash()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldUserCategoryID:
		m.ClearUserCategoryID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldUserCategoryID:
		m.ResetUserCategoryID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.user_category != nil {
		edges = append(edges, user.EdgeUserCategory)
	}
	if m.shopping_cart_user != nil {
		edges = append(edges, user.EdgeShoppingCartUser)
	}
	if m.user_token_user != nil {
		edges = append(edges, user.EdgeUserTokenUser)
	}
	if m.order_user != nil {
		edges = append(edges, user.EdgeOrderUser)
	}
	if m.addresses != nil {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.user_chat != nil {
		edges = append(edges, user.EdgeUserChat)
	}
	if m.user_card != nil {
		edges = append(edges, user.EdgeUserCard)
	}
	if m.user_message != nil {
		edges = append(edges, user.EdgeUserMessage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserCategory:
		if id := m.user_category; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeShoppingCartUser:
		ids := make([]ent.Value, 0, len(m.shopping_cart_user))
		for id := range m.shopping_cart_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTokenUser:
		ids := make([]ent.Value, 0, len(m.user_token_user))
		for id := range m.user_token_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrderUser:
		ids := make([]ent.Value, 0, len(m.order_user))
		for id := range m.order_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.addresses))
		for id := range m.addresses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserChat:
		ids := make([]ent.Value, 0, len(m.user_chat))
		for id := range m.user_chat {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCard:
		ids := make([]ent.Value, 0, len(m.user_card))
		for id := range m.user_card {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMessage:
		ids := make([]ent.Value, 0, len(m.user_message))
		for id := range m.user_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedshopping_cart_user != nil {
		edges = append(edges, user.EdgeShoppingCartUser)
	}
	if m.removeduser_token_user != nil {
		edges = append(edges, user.EdgeUserTokenUser)
	}
	if m.removedorder_user != nil {
		edges = append(edges, user.EdgeOrderUser)
	}
	if m.removedaddresses != nil {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.removeduser_chat != nil {
		edges = append(edges, user.EdgeUserChat)
	}
	if m.removeduser_card != nil {
		edges = append(edges, user.EdgeUserCard)
	}
	if m.removeduser_message != nil {
		edges = append(edges, user.EdgeUserMessage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeShoppingCartUser:
		ids := make([]ent.Value, 0, len(m.removedshopping_cart_user))
		for id := range m.removedshopping_cart_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserTokenUser:
		ids := make([]ent.Value, 0, len(m.removeduser_token_user))
		for id := range m.removeduser_token_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrderUser:
		ids := make([]ent.Value, 0, len(m.removedorder_user))
		for id := range m.removedorder_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAddresses:
		ids := make([]ent.Value, 0, len(m.removedaddresses))
		for id := range m.removedaddresses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserChat:
		ids := make([]ent.Value, 0, len(m.removeduser_chat))
		for id := range m.removeduser_chat {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserCard:
		ids := make([]ent.Value, 0, len(m.removeduser_card))
		for id := range m.removeduser_card {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserMessage:
		ids := make([]ent.Value, 0, len(m.removeduser_message))
		for id := range m.removeduser_message {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleareduser_category {
		edges = append(edges, user.EdgeUserCategory)
	}
	if m.clearedshopping_cart_user {
		edges = append(edges, user.EdgeShoppingCartUser)
	}
	if m.cleareduser_token_user {
		edges = append(edges, user.EdgeUserTokenUser)
	}
	if m.clearedorder_user {
		edges = append(edges, user.EdgeOrderUser)
	}
	if m.clearedaddresses {
		edges = append(edges, user.EdgeAddresses)
	}
	if m.cleareduser_chat {
		edges = append(edges, user.EdgeUserChat)
	}
	if m.cleareduser_card {
		edges = append(edges, user.EdgeUserCard)
	}
	if m.cleareduser_message {
		edges = append(edges, user.EdgeUserMessage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserCategory:
		return m.cleareduser_category
	case user.EdgeShoppingCartUser:
		return m.clearedshopping_cart_user
	case user.EdgeUserTokenUser:
		return m.cleareduser_token_user
	case user.EdgeOrderUser:
		return m.clearedorder_user
	case user.EdgeAddresses:
		return m.clearedaddresses
	case user.EdgeUserChat:
		return m.cleareduser_chat
	case user.EdgeUserCard:
		return m.cleareduser_card
	case user.EdgeUserMessage:
		return m.cleareduser_message
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeUserCategory:
		m.ClearUserCategory()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserCategory:
		m.ResetUserCategory()
		return nil
	case user.EdgeShoppingCartUser:
		m.ResetShoppingCartUser()
		return nil
	case user.EdgeUserTokenUser:
		m.ResetUserTokenUser()
		return nil
	case user.EdgeOrderUser:
		m.ResetOrderUser()
		return nil
	case user.EdgeAddresses:
		m.ResetAddresses()
		return nil
	case user.EdgeUserChat:
		m.ResetUserChat()
		return nil
	case user.EdgeUserCard:
		m.ResetUserCard()
		return nil
	case user.EdgeUserMessage:
		m.ResetUserMessage()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserCategoryMutation represents an operation that mutates the UserCategory nodes in the graph.
type UserCategoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	name                      *string
	clearedFields             map[string]struct{}
	user_category_user        map[int]struct{}
	removeduser_category_user map[int]struct{}
	cleareduser_category_user bool
	done                      bool
	oldValue                  func(context.Context) (*UserCategory, error)
	predicates                []predicate.UserCategory
}

var _ ent.Mutation = (*UserCategoryMutation)(nil)

// usercategoryOption allows management of the mutation configuration using functional options.
type usercategoryOption func(*UserCategoryMutation)

// newUserCategoryMutation creates new mutation for the UserCategory entity.
func newUserCategoryMutation(c config, op Op, opts ...usercategoryOption) *UserCategoryMutation {
	m := &UserCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeUserCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserCategoryID sets the ID field of the mutation.
func withUserCategoryID(id int) usercategoryOption {
	return func(m *UserCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *UserCategory
		)
		m.oldValue = func(ctx context.Context) (*UserCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserCategory sets the old UserCategory of the mutation.
func withUserCategory(node *UserCategory) usercategoryOption {
	return func(m *UserCategoryMutation) {
		m.oldValue = func(context.Context) (*UserCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserCategory entity.
// If the UserCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserCategoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[usercategory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserCategoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[usercategory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserCategoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, usercategory.FieldName)
}

// AddUserCategoryUserIDs adds the "user_category_user" edge to the User entity by ids.
func (m *UserCategoryMutation) AddUserCategoryUserIDs(ids ...int) {
	if m.user_category_user == nil {
		m.user_category_user = make(map[int]struct{})
	}
	for i := range ids {
		m.user_category_user[ids[i]] = struct{}{}
	}
}

// ClearUserCategoryUser clears the "user_category_user" edge to the User entity.
func (m *UserCategoryMutation) ClearUserCategoryUser() {
	m.cleareduser_category_user = true
}

// UserCategoryUserCleared reports if the "user_category_user" edge to the User entity was cleared.
func (m *UserCategoryMutation) UserCategoryUserCleared() bool {
	return m.cleareduser_category_user
}

// RemoveUserCategoryUserIDs removes the "user_category_user" edge to the User entity by IDs.
func (m *UserCategoryMutation) RemoveUserCategoryUserIDs(ids ...int) {
	if m.removeduser_category_user == nil {
		m.removeduser_category_user = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_category_user, ids[i])
		m.removeduser_category_user[ids[i]] = struct{}{}
	}
}

// RemovedUserCategoryUser returns the removed IDs of the "user_category_user" edge to the User entity.
func (m *UserCategoryMutation) RemovedUserCategoryUserIDs() (ids []int) {
	for id := range m.removeduser_category_user {
		ids = append(ids, id)
	}
	return
}

// UserCategoryUserIDs returns the "user_category_user" edge IDs in the mutation.
func (m *UserCategoryMutation) UserCategoryUserIDs() (ids []int) {
	for id := range m.user_category_user {
		ids = append(ids, id)
	}
	return
}

// ResetUserCategoryUser resets all changes to the "user_category_user" edge.
func (m *UserCategoryMutation) ResetUserCategoryUser() {
	m.user_category_user = nil
	m.cleareduser_category_user = false
	m.removeduser_category_user = nil
}

// Where appends a list predicates to the UserCategoryMutation builder.
func (m *UserCategoryMutation) Where(ps ...predicate.UserCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserCategory).
func (m *UserCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, usercategory.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercategory.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercategory.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown UserCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown UserCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usercategory.FieldName) {
		fields = append(fields, usercategory.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserCategoryMutation) ClearField(name string) error {
	switch name {
	case usercategory.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown UserCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserCategoryMutation) ResetField(name string) error {
	switch name {
	case usercategory.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown UserCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_category_user != nil {
		edges = append(edges, usercategory.EdgeUserCategoryUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercategory.EdgeUserCategoryUser:
		ids := make([]ent.Value, 0, len(m.user_category_user))
		for id := range m.user_category_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_category_user != nil {
		edges = append(edges, usercategory.EdgeUserCategoryUser)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usercategory.EdgeUserCategoryUser:
		ids := make([]ent.Value, 0, len(m.removeduser_category_user))
		for id := range m.removeduser_category_user {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_category_user {
		edges = append(edges, usercategory.EdgeUserCategoryUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case usercategory.EdgeUserCategoryUser:
		return m.cleareduser_category_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserCategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserCategoryMutation) ResetEdge(name string) error {
	switch name {
	case usercategory.EdgeUserCategoryUser:
		m.ResetUserCategoryUser()
		return nil
	}
	return fmt.Errorf("unknown UserCategory edge %s", name)
}

// UserTokenMutation represents an operation that mutates the UserToken nodes in the graph.
type UserTokenMutation struct {
	config
	op              Op
	typ             string
	id              *int
	token           *string
	expiration_date *time.Time
	_type           *string
	status          *string
	last_used       *string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*UserToken, error)
	predicates      []predicate.UserToken
}

var _ ent.Mutation = (*UserTokenMutation)(nil)

// usertokenOption allows management of the mutation configuration using functional options.
type usertokenOption func(*UserTokenMutation)

// newUserTokenMutation creates new mutation for the UserToken entity.
func newUserTokenMutation(c config, op Op, opts ...usertokenOption) *UserTokenMutation {
	m := &UserTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeUserToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserTokenID sets the ID field of the mutation.
func withUserTokenID(id int) usertokenOption {
	return func(m *UserTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *UserToken
		)
		m.oldValue = func(ctx context.Context) (*UserToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserToken sets the old UserToken of the mutation.
func withUserToken(node *UserToken) usertokenOption {
	return func(m *UserTokenMutation) {
		m.oldValue = func(context.Context) (*UserToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserTokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserTokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *UserTokenMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *UserTokenMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ClearToken clears the value of the "token" field.
func (m *UserTokenMutation) ClearToken() {
	m.token = nil
	m.clearedFields[usertoken.FieldToken] = struct{}{}
}

// TokenCleared returns if the "token" field was cleared in this mutation.
func (m *UserTokenMutation) TokenCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldToken]
	return ok
}

// ResetToken resets all changes to the "token" field.
func (m *UserTokenMutation) ResetToken() {
	m.token = nil
	delete(m.clearedFields, usertoken.FieldToken)
}

// SetExpirationDate sets the "expiration_date" field.
func (m *UserTokenMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *UserTokenMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ClearExpirationDate clears the value of the "expiration_date" field.
func (m *UserTokenMutation) ClearExpirationDate() {
	m.expiration_date = nil
	m.clearedFields[usertoken.FieldExpirationDate] = struct{}{}
}

// ExpirationDateCleared returns if the "expiration_date" field was cleared in this mutation.
func (m *UserTokenMutation) ExpirationDateCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldExpirationDate]
	return ok
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *UserTokenMutation) ResetExpirationDate() {
	m.expiration_date = nil
	delete(m.clearedFields, usertoken.FieldExpirationDate)
}

// SetType sets the "type" field.
func (m *UserTokenMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserTokenMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *UserTokenMutation) ClearType() {
	m._type = nil
	m.clearedFields[usertoken.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *UserTokenMutation) TypeCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *UserTokenMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, usertoken.FieldType)
}

// SetStatus sets the "status" field.
func (m *UserTokenMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserTokenMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserTokenMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[usertoken.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserTokenMutation) StatusCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserTokenMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, usertoken.FieldStatus)
}

// SetLastUsed sets the "last_used" field.
func (m *UserTokenMutation) SetLastUsed(s string) {
	m.last_used = &s
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *UserTokenMutation) LastUsed() (r string, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldLastUsed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *UserTokenMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[usertoken.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *UserTokenMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *UserTokenMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, usertoken.FieldLastUsed)
}

// SetUserID sets the "user_id" field.
func (m *UserTokenMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserTokenMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserToken entity.
// If the UserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserTokenMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserTokenMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[usertoken.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserTokenMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[usertoken.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserTokenMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, usertoken.FieldUserID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserTokenMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usertoken.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserTokenMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserTokenMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserTokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserTokenMutation builder.
func (m *UserTokenMutation) Where(ps ...predicate.UserToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserToken).
func (m *UserTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.token != nil {
		fields = append(fields, usertoken.FieldToken)
	}
	if m.expiration_date != nil {
		fields = append(fields, usertoken.FieldExpirationDate)
	}
	if m._type != nil {
		fields = append(fields, usertoken.FieldType)
	}
	if m.status != nil {
		fields = append(fields, usertoken.FieldStatus)
	}
	if m.last_used != nil {
		fields = append(fields, usertoken.FieldLastUsed)
	}
	if m.user != nil {
		fields = append(fields, usertoken.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usertoken.FieldToken:
		return m.Token()
	case usertoken.FieldExpirationDate:
		return m.ExpirationDate()
	case usertoken.FieldType:
		return m.GetType()
	case usertoken.FieldStatus:
		return m.Status()
	case usertoken.FieldLastUsed:
		return m.LastUsed()
	case usertoken.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usertoken.FieldToken:
		return m.OldToken(ctx)
	case usertoken.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	case usertoken.FieldType:
		return m.OldType(ctx)
	case usertoken.FieldStatus:
		return m.OldStatus(ctx)
	case usertoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	case usertoken.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usertoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case usertoken.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	case usertoken.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usertoken.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usertoken.FieldLastUsed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	case usertoken.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserTokenMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserTokenMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserTokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usertoken.FieldToken) {
		fields = append(fields, usertoken.FieldToken)
	}
	if m.FieldCleared(usertoken.FieldExpirationDate) {
		fields = append(fields, usertoken.FieldExpirationDate)
	}
	if m.FieldCleared(usertoken.FieldType) {
		fields = append(fields, usertoken.FieldType)
	}
	if m.FieldCleared(usertoken.FieldStatus) {
		fields = append(fields, usertoken.FieldStatus)
	}
	if m.FieldCleared(usertoken.FieldLastUsed) {
		fields = append(fields, usertoken.FieldLastUsed)
	}
	if m.FieldCleared(usertoken.FieldUserID) {
		fields = append(fields, usertoken.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserTokenMutation) ClearField(name string) error {
	switch name {
	case usertoken.FieldToken:
		m.ClearToken()
		return nil
	case usertoken.FieldExpirationDate:
		m.ClearExpirationDate()
		return nil
	case usertoken.FieldType:
		m.ClearType()
		return nil
	case usertoken.FieldStatus:
		m.ClearStatus()
		return nil
	case usertoken.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	case usertoken.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown UserToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserTokenMutation) ResetField(name string) error {
	switch name {
	case usertoken.FieldToken:
		m.ResetToken()
		return nil
	case usertoken.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	case usertoken.FieldType:
		m.ResetType()
		return nil
	case usertoken.FieldStatus:
		m.ResetStatus()
		return nil
	case usertoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	case usertoken.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usertoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usertoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usertoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case usertoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserTokenMutation) ClearEdge(name string) error {
	switch name {
	case usertoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserTokenMutation) ResetEdge(name string) error {
	switch name {
	case usertoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserToken edge %s", name)
}
